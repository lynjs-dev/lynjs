# TypeScript 모노레포 뼈대 만들기

프로젝트의 기본 구조와 버저닝·브랜치 전략을 정리한 이후, 실제로 프로젝트를 생성하고 배포 파이프라인을 구축하는 단계로
넘어간다. 이 단계에서는 단순함을 우선으로 하며, 코드 작성이나 Babel 플러그인 설치는 포함하지 않는다. 비어 있는 프로젝트
뼈대와 기본적인 TypeScript 설정까지만 준비하며, 확장적인 설정이나 기능 추가는 이후 단계에서 진행한다.

## 목표

이 단계의 목표는 **비어 있는 TypeScript 모노레포 뼈대**를 준비하는 것이다. 달성해야 할 구체적인 항목은 다음과 같다.

1. **예측 가능한 빌드 체인 확보:** 초기에는 코드 변환 과정이 단순하고 직관적이어야 한다. 불필요한 번들링을 생략하고,
   TypeScript와 Babel만으로 최소한의 개발 파이프라인을 마련한다.

2. **모노레포 구조 수립:** 루트 패키지(`lynjs`)를 퍼블리시 대상으로 설정하고, 내부적으로는 `packages/` 디렉터리를
   중심으로 확장 가능한 구조를 마련한다. 외부 사용자는 모노레포 구조를 의식하지 않고 단일 패키지처럼 사용할 수 있어야
   한다.

3. **일관된 타입스크립트 환경 구성:** 모든 패키지가 공통의 `tsconfig.base.json`을 상속하도록 하여, 일관된 타입 검사
   규칙과 유지보수 편의성을 확보한다.

4. **확장성 고려:** 지금은 코드가 비어 있지만, 향후 데코레이터, JSX 규약, Babel 플러그인 등을 추가하더라도 기존 뼈대를
   크게 변경하지 않고 확장할 수 있어야 한다.

이렇게 하면 이번 단계에서 준비할 범위와 다음 단계로 넘길 부분이 명확해진다.

## 무엇이 필요한가 (언어, 번들링, 트랜스파일러 선택)

- **언어:** TypeScript만 지원
- **번들링:** 하지 않음 (초기에는 트랜스파일만 수행)
- **JSX:** 필요 → 트랜스파일러는 Babel 사용

지금은 성능 최적화나 런타임 마법보다, **코드가 어떻게 변환되어 배포되는지가 눈에 보이는 예측 가능한 빌드 체인**이 더
중요하다. Babel은 JSX 같은 실험 요소를 적용하더라도 변환 규칙이 명확하고 커스터마이즈가 쉬워, 초기 단계에서 문제 원인을
추적하기에 적합하다. 따라서 이번 단계에서는 트랜스파일러로 Babel을 선택한다.

## 왜 Babel인가

Babel은 다음과 같은 장점으로 인해 초기 학습 비용 대비 높은 통제력과 확장성을 제공한다.

1. **정교한 AST 제어:**
   - 데코레이터, JSX, 호스트/구현 분리 같은 문법 레벨 최적화를 지원하기 위해 플러그인 단위로 세밀한 조정이 가능하다.
     얇게 시작하더라도 필요 시 LynJS 전용 플러그인을 도입하여 DX를 강화할 수 있다.

2. **JSX 파이프라인의 표준:**
   - JSX 실험을 검증된 생태계에서 진행할 수 있다. Babel은 JSX에 대한 레퍼런스 구현과 풍부한 옵션을 제공하며,
     프리셋/플러그인 조합을 통해 React/Lit/Solid 스타일을 넘나드는 실험이 가능하다. LynJS만의 JSX 규약을 시험하기에도
     적합하다.

3. **모노레포 친화성:**
   - 패키지별로 상이한 빌드 옵션이 필요할 경우(예: `@lynjs/core`와 `@lynjs/babel-…`) 루트 프리셋 + 패키지별 오버라이드
     패턴이 유용하다. CI 환경에서 병렬 빌드와 캐시 전략 수립에도 유리하다.

4. **도구 연동의 유연성:**
   - Vite, Vitest, Jest 같은 도구와의 호환성이 뛰어나며, `babel-jest`나 `@vitest/coverage-v8`과도 원활히 동작한다.
     하나의 트랜스폼 변경이 전체 라인업에 일관되게 반영되는 점 또한 장점이다.

5. **타이핑은 TS, 변환은 Babel:**
   - 타입 검사는 TypeScript가 담당하고, 코드 변환은 Babel이 담당한다. 두 축을 분리하면 트러블슈팅이 명확해지고,
     TypeScript 5.x의 데코레이터/JSX 변화가 발생하더라도 독립적으로 교체·조정이 가능하다.

6. **성능과 예측 가능성의 균형:**
   - SWC나 ESBuild는 빠르지만 커스텀 트랜스폼 자유도가 떨어질 수 있다. LynJS는 장기적으로 “문법 차원에서 DX를 강화”해야
     하므로, Babel의 성숙한 플러그인 생태계와 디버깅 경험이 안정성을 확보한다.

## 프로젝트 디렉터리 만들기

```bash
mkdir lynjs && cd lynjs
git init
npm init -y
```

## 루트 package.json과 workspaces 설정

루트 package.json은 퍼블리시 대상이자 워크스페이스의 루트이다. 모노레포 전제를 명확히 하기 위해 다음과 같이 설정한다.

- `private: false` → 루트 패키지가 퍼블리시 대상임을 명시
- `workspaces` → `packages/*` 지정
- 소스는 TypeScript 그대로 제공하므로 빌드 스크립트는 비워둔다
- ESM 기본을 가정해 `"type": "module"`을 설정

**package.json**

```json
{
  "name": "lynjs",
  "version": "0.0.0",
  "private": false,
  "type": "module",
  "workspaces": ["packages/*"],
  "exports": {},
  "sideEffects": false,
  "scripts": {
    "build": "echo \"(root) nothing to build yet\"",
    "clean": "git clean -fdX -e node_modules",
    "test": "echo \"(root) no tests yet\" && exit 0"
  },
  "engines": {
    "node": ">=18"
  }
}
```

## @lynjs/core 패키지 생성

`@lynjs/core`는 LynJS의 기본 클래스와 최소한의 뼈대를 제공하는 패키지다. 상태 관리나 유틸리티 같은 구체적 동작은 다른
패키지들이 담당하며, 이들이 모여 core를 완성한다.

```bash
mkdir -p packages/core
```

## 디렉터리 구조

```
lynjs/
├─ package.json          # 퍼블리시 대상 (사용자는 'lynjs'만 본다)
└─ packages/
   └─ core/
```

**packages/core/package.json**

```json
{
  "name": "@lynjs/core",
  "version": "0.0.0",
  "private": true,
  "type": "module"
}
```

> 워크스페이스 인식을 위해 최소한의 package.json을 작성한다. 내부 전용이므로 `private: true`로 설정한다.

## 기본 TypeScript 설정

모노레포 환경에서는 여러 패키지가 존재하므로, 각 패키지에 tsconfig.json이 필요하다. 설정을 매번 반복하면 관리가 어렵기
때문에 루트에 **공통 베이스(tsconfig.base.json)**를 두고, 각 패키지가 이를 `extends` 하도록 한다.

**tsconfig.base.json**

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "NodeNext",
    "lib": ["ES2022", "DOM"],
    "jsx": "preserve",
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "allowJs": true,
    "checkJs": false,
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "noEmit": true
  }
}
```

## 패키지별 tsconfig.json 확장 구조

패키지는 `tsconfig.base.json`을 기반으로 확장하며, 각자의 특화된 부분만 작성한다.

**packages/core/tsconfig.json**

```json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {},
  "include": ["src/**/*.ts"],
  "exclude": ["dist", "node_modules"]
}
```

이 구조를 사용하면 뼈대만 있는 프로젝트라 하더라도, 패키지가 늘어날 때 일관된 타입스크립트 규칙을 유지할 수 있다.

## 활용 방안

- 초기에는 **코드 변환 파이프라인을 단순화**하여 디버깅과 확장을 쉽게 한다.
- 팀원 수와 패키지가 늘어나더라도, **공통 TypeScript 베이스**를 통해 규칙을 일괄적으로 조정할 수 있다.
- Babel 프리셋/플러그인을 추가하더라도, 기존 구조는 변하지 않고 안정적으로 확장된다.
