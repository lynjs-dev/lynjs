# Frontend Framework 만들기

현재 하나의 프론트엔드 프레임워크를 만들기 위한 준비가 진행 중이다. 이름은 LynJS다.

LynJS는 웹 표준인 Custom Elements를 기반으로 하면서, UI를 본질적으로 객체로 바라보는 객체지향 프레임워크로 설계될
예정이다. Virtual DOM을 사용하지 않고도 미세한 단위로 직접 갱신하는 방식을 채택하려 하며, React의 JSX 문법을 지원하여
선언적으로 UI를 표현할 수 있도록 할 계획이다. 또한 SolidJS가 보여주는 fine-grained한 성능 최적화 방식도 참고하면서,
플랫폼 친화적인 구조 위에 React의 생산성과 객체지향적 사고를 결합하는 새로운 형태의 프레임워크를 목표로 하고 있다.

그렇다면 왜 이런 프레임워크를 만들려고 하는 걸까? 그 시작은 작년, 통신사의 추천 시스템 프로젝트에서 프론트엔드 팀을 돕게
되면서 처음으로 React를 본격적으로 사용하게 된 경험에서 비롯된다. 이전까지는 백엔드 개발자로서 서버와 데이터베이스를
다루는 일이 대부분이었고, 프론트엔드 작업을 하더라도 주로 Vanilla JS를 쓰거나 프레임워크 문서를 가볍게 훑어보는
정도였다. 그래서 현업에서 React를 직접 다루게 된 것은 큰 전환점이 되었다.

React는 분명 흥미로운 프레임워크다. “UI는 상태다”라는 단순한 정의와 그 철학은 직관적이면서도 매력적이다. 하지만 React가
이를 구현하는 방식, 특히 함수형 컴포넌트와 사이드이펙트를 처리하기 위한 다양한 기법들은 불필요하게 복잡한 꼼수처럼
느껴진다. 이미 웹 표준인 Custom Elements와 그에 따른 라이프사이클을 알고 있는 상황에서, UI를 객체로 바라보고 자연스러운
생명주기를 따라가는 방식이 훨씬 직관적이라고 생각된다. React가 함수라는 틀에 맞추어 사이드이펙트를 관리하는 방식은
깔끔한 해결책이면서도 동시에 억지로 맞춘 우회로처럼 보인다.

또 하나의 불만은 호환성 문제다. React로 만든 컴포넌트는 React 환경에서만 잘 작동하고, Vue나 Svelte 같은 다른
프레임워크에서는 재사용하기 어렵다. 이때 떠오른 생각은 명확하다. “만약 Custom Elements로 만들었다면? 웹 표준을 따랐다면?
이런 문제는 생기지 않았을 텐데.” UI 컴포넌트를 프레임워크마다 다시 만들어야 한다는 점은 마치 레고 블록이 세트마다 규격이
달라 서로 끼울 수 없는 것처럼 답답하게 느껴진다.

Virtual DOM 역시 의문을 가지게 하는 부분이다. React는 Virtual DOM을 통해 성능을 최적화한다고 하지만, 실제로는 상태가
바뀔 때마다 전체 컴포넌트가 다시 렌더링되고, diff 과정을 거쳐 일부만 갱신되도록 동작한다. 평소에는 문제가 없지만,
사용자가 입력 중일 때 작은 상태 변화가 발생하면 포커스가 튀거나 입력이 끊기는 문제가 생긴다. 물론 해결 방법은 있지만,
그것은 결국 더 많은 불필요한 코드를 작성해야 한다는 뜻이다. 자연스럽게 이런 의문이 떠올랐다.

“굳이 diff를 할 필요가 있을까? 그냥 바뀐 부분만 곧장 업데이트하면 되는 거 아닌가?”

그럼에도 불구하고 React에서 배운 것 중 하나는 매우 매력적이다. 바로 JSX다. HTML과 JavaScript가 부드럽게 섞여 하나의
언어처럼 UI를 기술하는 방식은 기존의 document.createElement나 템플릿 문자열보다 훨씬 자연스럽고 읽기 쉽다. 선언적이고
직관적인 JSX 문법은 경험한 모든 불편함과 별개로, 앞으로 만들 프레임워크에 반드시 포함하고 싶은 중요한 도구다. React의
사이드 이펙트 관리 방식이 억지로 맞춘 우회로처럼 보였지만, render 메서드 같은 곳에서 보조적인 수단으로 활용한다면 꽤
훌륭한 도구가 될 수 있다는 점도 알게 되었다.

이런 경험들이 모여 LynJS의 방향이 조금씩 그려지고 있다. UI는 객체라는 관점을 반영하고, 웹 표준을 지키면서도 불필요한
diff 과정을 거치지 않고 변경된 부분만 즉시 갱신하는 효율적인 방식을 추구한다. 동시에 JSX가 주는 생산성과 가독성을
유지하며, LynJS로 만든 컴포넌트가 다양한 환경에서도 재사용될 수 있도록 하는 것을 목표로 한다.

## 왜 LynJS인가: 기존 프레임워크들과 다른 선택

새로운 프레임워크를 만들겠다고 마음먹은 후, 이미 존재하는 선택지들을 살펴보았다. React, Vue, Svelte, SolidJS, 그리고
Lit. 이들은 모두 훌륭한 도구들이고, 각자 뚜렷한 철학과 강점을 가지고 있었다. 하지만 중요하게 생각하는 가치와는 조금씩
어긋나 있었다.

찾고 있던 것은 네 가지였다.

- UI는 객체다라는 철학을 중심에 둔 객체지향적 UI
- Virtual DOM 없이 변경 지점만 직접 갱신하는 fine-grained reactivity
- JSX 문법이 주는 생산성과 가독성
- 웹 표준(Custom Elements) 기반의 이식성

기존 프레임워크들은 각각 이 중 일부를 충족했지만, 네 가지를 동시에 만족시키는 것은 없었다. 그래서 결국 LynJS라는
이름으로 직접 만들어보기로 했다.

## 주요 프레임워크 비교

| 항목                | **React**            | **Vue**                | **Svelte**            | **SolidJS**             | **Lit**                   | **LynJS(계획)**                        |
| ------------------- | -------------------- | ---------------------- | --------------------- | ----------------------- | ------------------------- | -------------------------------------- |
| **핵심 관점**       | UI=State, 함수형     | 선언적 + 양방향 바인딩 | 컴파일러 중심         | Fine-grained 반응성     | Web Components 중심       | **UI는 객체(객체지향)**                |
| **렌더링/업데이트** | Virtual DOM diff     | Virtual DOM + Template | 빌드 시 DOM 코드 생성 | 직접 갱신(fine-grained) | 템플릿 리터럴 + 반응 속성 | **VDOM 없이 변경 지점 직접 갱신**      |
| **반응성 모델**     | 훅(useState/effect)  | Proxy 반응성           | 빌드 타임 분석        | Signal/Effect           | Reactive Properties       | **Signal/Effect 계열(계획)**           |
| **웹 표준 활용**    | 낮음                 | 제한적                 | 제한적                | 낮음                    | **높음(Custom Elements)** | **높음(Custom Elements 기반)**         |
| **JSX 지원**        | **공식**             | 제한적/커뮤니티        | X                     | **공식**                | X                         | **공식 지원(계획)**                    |
| **컴포넌트 이식성** | 프레임워크 종속      | 종속                   | 종속(컴파일 의존)     | 종속                    | 표준 기반                 | **표준 기반 산출물 지향**              |
| **빌드 도구 의존**  | JSX 변환 필요        | SFC/빌드 필요          | 강함(컴파일러)        | JSX 변환 필요           | 낮음                      | **JSX 변환 때문에 필수**               |
| **표준↔DX 태도**   | 프레임워크 규칙 우선 | 프레임워크 규칙 우선   | 빌드 규약 우선        | 성능·미세반응 우선      | **표준 엄격 준수**        | **표준 지향 + DX 저해 시 내부는 유연** |

## 각 프레임워크의 장단점

- `React`: JSX라는 훌륭한 도구를 제공하고 거대한 생태계를 가지고 있다. 하지만 함수형 컴포넌트와 훅 기반의 사이드이펙트
  관리는 불필요하게 복잡한 패턴처럼 느껴진다. Virtual DOM diff 또한 효율적이지만, 굳이 diff를 하지 않고 변경된 지점만
  곧장 갱신할 수 있다면 더 단순하고 명확하지 않을까 하는 의문이 있다.
- `Vue`: 학습 곡선이 완만하고 생산성이 뛰어나다. 그러나 여전히 프레임워크의 규칙 안에서만 움직일 수 있고, Custom
  Elements 기반의 자유로운 이식성과는 거리가 있었다.
- `Svelte`: 빌드 타임에 많은 일을 처리해 최적화하는 접근은 독창적이다. 하지만 모든 걸 빌드 단계에서 해결하기보다,
  런타임에서도 자연스럽게 동작하는 방식을 원했다. JSX를 쓰기 위해 빌드 도구는 필수이기에, 빌드 의존성을 줄이는 것이
  목표는 아니었다.
- `SolidJS`: fine-grained reactivity의 장점을 제대로 보여주었다. 하지만 웹 표준 기반이나 객체지향적 UI라는 철학과는 다소
  거리가 있었다.
- `Lit`: 웹 표준을 충실히 따르는 프레임워크다. 하지만 템플릿 리터럴 기반의 문법은 JSX만큼 직관적이지 않았다. JSX의
  생산성과 가독성을 포기하고 싶지 않았던 상황에서, Lit만으로는 아쉬움이 있었다.

## LynJS와 Lit, 그리고 굳이 LynJS를 만들려는 이유

가장 많이 비교 대상은 Lit이다. 사실 LynJS의 철학은 Lit과 매우 비슷하다. 두 프레임워크 모두 웹 표준을 존중하고, Custom
Elements를 중심에 두며, 프레임워크 종속성을 최소화하려 한다. 그래서 “그렇다면 Lit을 쓰면 되지 않나?”라는 질문이 나올 수
있다.

하지만 LynJS를 따로 만들려는 이유는 분명하다.

1. `표준을 지향하되, DX를 해치지 않는다`: LynJS는 Custom Elements와 표준 라이프사이클을 따르며, 산출물 수준에서는 철저히
   웹 표준을 지킨다. 그러나 내부 구현에서까지 표준의 형식에 스스로를 묶어 개발자 경험(DX)을 희생하지는 않는다. 즉,
   형식적 표준과 결과물의 표준은 철저히 따르되, 내부에서는 DX를 높이기 위한 합리적 해석과 확장을 허용한다.
2. `JSX 공식 지원`: Lit은 템플릿 리터럴 기반이지만, LynJS는 JSX를 공식 지원한다. JSX는 선언적 UI를 작성할 때 직관성과
   생산성을 극대화하며, 이는 DX를 강화하는 핵심 요소다.
3. `fine-grained 직접 갱신`: Lit은 템플릿 단위로 업데이트가 일어나지만, LynJS는 더 세밀한 fine-grained reactivity를
   사용해 변경된 지점만 직접 갱신하는 방식을 채택한다.

즉 LynJS는 Lit의 표준 기반 철학을 이어받으면서도, 표준에 과도하게 묶이지 않고 DX를 해치지 않는 길을 선택한다. 여기에
JSX와 fine-grained 모델을 결합하여, 더 직관적이고 이식성이 높으며 효율적인 UI 개발 경험을 제공하려는 것이 LynJS의
목표다.

## LynJS가 선택한 네 가지 원칙

1. 객체지향적 UI — UI는 함수가 아니라 객체다. Custom Elements의 표준 라이프사이클을 따르고, 객체의 생명주기를 중심으로
   상태와 속성을 다룬다.
2. fine-grained 직접 갱신 — Virtual DOM diff 대신, 변경된 지점만 곧장 갱신한다.
3. JSX 공식 지원 — 선언적이고 직관적인 UI 문법을 위해 JSX를 기본 전제로 한다. 빌드 도구 의존성은 이를 위해 적극
   수용한다.
4. 웹 표준 기반 이식성 — LynJS로 만든 컴포넌트는 특정 프레임워크에 묶이지 않고, 다양한 환경에서 재사용될 수 있다.

그래서 LynJS는 단순히 또 하나의 프레임워크가 아니다. 기존 프레임워크들이 놓친 지점, Lit조차 채우지 못한 부분을 메우려는
시도다. 바라보는 네 가지 원칙—객체지향적 UI, fine-grained 직접 갱신, JSX, 웹 표준 기반 이식성—을 중심으로, LynJS는
앞으로 만들어갈 새로운 해답이 될 것이다.

## LynJS를 만들기 위한 고민

하지만 프레임워크를 새로 만든다는 건, 단순히 코드 몇 줄을 짜는 일이 아니었다. 가장 먼저 부딪힌 건 이런 질문이었다.

“이걸 어떤 도구 위에서 만들어야 하지?”

처음에는 단순히 TypeScript와 Babel만 있으면 충분할 거라 생각했다. 타입 안정성도 확보되고, 요즘 대부분의 프로젝트가
그러하듯 자연스럽게 선택할 수 있었기 때문이다.

그런데 막상 세부적인 그림을 그리려니 고민이 끝없이 이어졌다.

- JSX는 어떻게 트랜스파일링할까? React, Solid, Svelte 모두 각자의 방식을 갖고 있는데, LynJS만의 방식을 직접 구현해야
  한다.
- 객체 지향에 맞는 fine-grained reactivity는 어떤 형태로 녹여낼 수 있을까? 함수형에 치우친 기존 패러다임과 다르게,
  클래스와 객체의 생명주기에 어울리는 설계가 필요하다.
- **HMR(Hot Module Replacement)**과 **SSR(Server-Side Rendering)**은 어떤 방식으로 지원해야 할까? 단순히 돌아가는 수준이
  아니라, 실제로 개발자가 쓰기 편한 경험을 제공할 수 있어야 한다.
- 개발 환경은 또 어떤 도구를 선택해야 할까? Webpack처럼 무겁지만 안정적인 도구를 쓸 것인가, 아니면 Vite처럼 가볍고 빠른
  대안을 채택할 것인가.
- 사용자 경험은 어떻게 만들어야 할까? LynJS로 프로젝트를 시작하는 과정이 번거롭다면 아무리 뛰어난 기능이 있어도 외면받을
  것이다. npx create-lynjs-app 같은 간단한 진입점을 제공할 수 있을까?
- 테스트와 모노레포 구조는 어떻게 가져가야 할까? 여러 패키지가 동시에 맞물려 돌아가야 하는데, 유지보수성과 확장성을
  놓치면 금세 한계에 부딪히게 된다.
- 문서화는 어떤 방식으로 해야 할까? 단순한 API 레퍼런스만으로 충분하지 않다. 튜토리얼, 가이드, 예제, 디자인 원칙까지
  함께 녹여내야 개발자가 “이 프레임워크를 왜 써야 하는지” 직관적으로 이해할 수 있다. Docusaurus, Astro, Next.js 같은
  정적 사이트 생성기를 활용하는 것도 고민의 일부다.
- 배포는 어떻게 할까? npm에 단순히 패키지를 올리는 걸로 끝날까? ESModule과 CommonJS를 동시에 지원해야 할까? 브라우저
  환경과 Node.js 환경을 나눠 배포해야 할까? 번들링을 어디까지 하고, 어디서부터는 사용자의 선택에 맡길까?
- 그리고 마지막으로, 어떻게 사람들에게 알릴까? 좋은 코드를 짜는 것만으로는 아무도 찾아오지 않는다. 블로그 글, 문서, 예제
  코드, 트위터 해커뉴스 같은 채널까지 — “LynJS라는 이름을 어떻게 개발자들 앞에 가져갈 것인가”가 결국 생존을 좌우한다.

돌아보면, "도구를 무엇으로 쓸까?"라는 문제는 단순한 기술 선택이 아니었다. 그 안에는 LynJS가 어떤 철학을 갖고, 어떤
방향을 향해야 하는지가 고스란히 담겨 있었다. 결국 도구를 선택하는 과정은 곧 **LynJS라는 프레임워크를 정의하는
과정**이었다.

그리고 마지막 고민, “사람들에게 어떻게 알릴까?”에 대해서는 이렇게 답을 내렸다. **LynJS를 개발하는 과정 자체를 기록하고
공유하는 것**.

앞으로 틈틈이 개발 과정을 포스팅하며, 겪은 고민과 선택을 있는 그대로 남기려 한다. 그것이 곧 LynJS를 알리는 방법이자,
같은 길을 고민하는 사람들과 이어지는 가장 자연스러운 방법일 테니까.
