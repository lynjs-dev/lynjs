# 버전 관리 — LynJS의 SemVer 운영 가이드

## 버전 정책의 중요성

## 1. 버전 정책의 중요성

작은 사이드 프로젝트라면 `v1`, `v2`처럼 버전을 대충 올려도 큰 문제가 없다.
혼자 쓰는 코드니까 누가 뭐라 할 사람도 없고, 본인만 이해하면 되기 때문이다.

하지만 프레임워크처럼 **여러 개발자가 기여**하고, **외부 사용자**가 쓰는 오픈소스라면 상황은 완전히 달라진다.
이때 버전은 단순한 숫자가 아니라 **약속과 신뢰의 신호**가 된다.

- 사용자 입장에서는:
  → “이 업데이트는 단순한 버그 수정일까?”
  → “새 기능이 추가됐을까?”
  → “아니면 기존 코드가 깨질 수도 있는 메이저 변경일까?”
  버전 숫자만 보고도 위험도를 판단할 수 있어야 한다.

- 개발자 입장에서는:
  → 변경 이력을 체계적으로 관리할 수 있다.
  → 팀 단위 협업에서 릴리스 시점을 조율하기 쉽다.
  → CI/CD, 자동 배포 도구와 맞물려 안정적인 배포 흐름을 만든다.

결국 **버전 관리 정책이 없다면** 어떻게 될까?

- “이전 버전에서는 잘 되던 게 왜 갑자기 깨졌지?”라는 이슈가 폭발한다.
- 패키지를 업그레이드할 때 매번 코드를 열어 확인해야 한다.
- 릴리스 과정이 즉흥적으로 흘러가고, 프로젝트에 대한 신뢰가 떨어진다.

> 버전은 그냥 숫자가 아니다.
> **“지금 이 상태의 코드를 안심하고 쓸 수 있는가?”를 알려주는 최소한의 언어**다.

그래서 다른 오픈 소스가 그렇듯 LynJS또한 처음부터 **명확한 버전 정책**을 세우는 걸 필수 조건으로 잡았다.

## Semantic Versioning(SemVer) 소개

프레임워크나 라이브러리는 시간이 지날수록 새 기능이 추가되고, 버그가 수정되며, 때때로 호환성이 깨지는 큰 변화도 발생한다.
이때 개발자와 사용자가 같은 언어로 “이번 릴리스가 어떤 성격인지”를 이해할 수 있어야 한다.

그 역할을 해주는 게 바로 Semantic Versioning, 줄여서 SemVer다.
지금은 거의 모든 오픈소스 프로젝트가 따르는 사실상의 표준 버전 체계다.

### 규칙 설명

버전은 `MAJOR.MINOR.PATCH`로 표기한다.

- **MAJOR:** 기존과 호환되지 않는 변경 (Breaking change)
- **MINOR:** 호환성을 유지하면서 새로운 기능 추가
- **PATCH:** 버그 수정, 내부 개선

예:

- `16 → 17`: 호환성 변경 포함
- `16.8 → 16.9`: 새 기능 추가 (마이너)
- `16.8.1 → 16.8.2`: 버그 수정 (패치)

### 과적용 사례

- 단순 리팩터링인데 `MAJOR`로 올리기 → 불필요한 부담
- 사소한 API 옵션 추가인데 `PATCH`로 올리기 → 사용자 혼란
  > 규칙을 엄격하게 적용하되, **과하지 않게** 쓰는 게 중요하다.

### LynJS가 적용하려는 이유

- 이미 오픈소스 생태계의 사실상 표준
- 사용자에게 익숙하기 때문에 학습 비용 없음
- npm 의존성 해석이 SemVer를 기본 가정하고 있기 때문에 충돌 방지
- Changesets, semantic-release 등 자동화 도구와 잘 연계

### 초기 0.x 버전 운영 방침

LynJS는 초반엔 0.x.x로 시작한다.

- **브레이킹 변경도 MINOR**로 올린다 (`0.3.1 → 0.4.0`)
- 릴리스 노트 최상단에 **[BREAKING]** 배지로 강조
- `1.0.0` 이후부터 엄격한 SemVer 준수

## SemVer 사용 방법

### MAJOR / MINOR / PATCH

- `feat`: 보통 minor
- `fix`: 보통 patch
- `perf`, `refactor`: patch (외부 API 불변일 때)
- `docs`, `test`, `chore`: 버전 변경 없음

### 프리릴리스와 dist-tag

- `0.7.0-beta.1` → 실험/다음 버전 테스트
- npm `dist-tag`를 활용해 채널 관리
  ```bash
  npm dist-tag add lynjs@0.7.0-beta.1 next
  npm dist-tag add lynjs@0.6.3 latest
  ```

### 릴리스 노트 작성 원칙

- 고정 섹션: `Added / Changed / Fixed / Deprecated / Removed / Security / Docs`
- Breaking change는 맨 위에 `[BREAKING]` 강조
- 가능한 한 **마이그레이션 코드 예시** 제공

## 모노레포에서의 버전 전략

### 독립 버전 관리 vs 일괄 버전 관리

- **일괄(Lerna fixed mode)**
  - 모든 패키지의 버전을 항상 동일하게 유지한다.
  - 장점은 단순하고 릴리스 동기화가 쉽다는 점이다.
  - 단점은 실제로 변경이 없는 패키지도 같이 버전이 올라가 불필요한 bump가 많아진다는 점이다.

- **독립(Independent mode)**
  - 각 패키지를 개별적으로 버전 관리한다.
  - 장점은 변경이 있는 패키지만 버전을 올리기 때문에 유연성이 높다.
  - 단점은 패키지별로 버전이 다르다 보니 관리 복잡도가 올라간다는 점이다.

### LynJS의 선택

- **독립 버전 관리** 채택
- `lynjs` 메타 패키지를 단일 진입점으로 노출
- 내부 서브패키지는 모두 `"*"`로 참조
- 릴리스 노트는 패키지별 상세 + 루트 요약본

### 호환성 매트릭스 정리

| 패키지        | 지원 lynjs 범위 | 비고                                       |
| ------------- | --------------- | ------------------------------------------ |
| @lynjs/dom    | `*` (내부)      | lynjs와 함께 설치 (0.7에 신규 DOM adapter) |
| @lynjs/env    | `*` (내부)      | 테스트 플래그 변경 예정 (Deprecated)       |
| 외부 플러그인 | `>=0.6 <1`      | peerDependencies로 lynjs 범위 명시         |

## 내부 패키지에서 의존성 버전 적용 방법

- 내부 패키지끼리는 **항상 `"*"` 버전**을 사용한다.
- 워크스페이스/Changesets가 배포 시 자동으로 현재 버전으로 치환한다.
- 장점:
  - 변경 시 불필요한 버전 bump 방지
  - 관리 단순화
  - 내부 구조가 바뀌어도 사용자 경험엔 영향 없음

예시:

```jsonc
{
  "name": "lynjs",
  "version": "0.6.0",
  "dependencies": {
    "@lynjs/core": "*",
    "@lynjs/dom": "*",
    "@lynjs/reactive": "*",
  },
  "optionalDependencies": {
    "@lynjs/ssr": "*",
  },
}
```

## 외부 패키지에서 의존성 버전 적용 방법

### peerDependencies로 `lynjs` 명시

외부 플러그인은 내부 서브패키지(`@lynjs/core` 등)가 아니라, **`lynjs` 자체**를 peerDependencies로 의존해야 한다.

```jsonc
{
  "name": "@acme/lynjs-fancy-plugin",
  "peerDependencies": {
    "lynjs": ">=0.6 <1",
  },
}
```

### 플러그인 개발 가이드

- 항상 `lynjs` 공개 API만 사용한다.
- 내부 패키지에 직접 의존하지 않는다.
- peerDependencies를 통해 앱이 설치한 `lynjs`와 단일 인스턴스를 공유한다.
- 필요하다면 `devDependencies`에 `lynjs`를 추가해 개발 환경에서만 사용한다.

# 정리

- **SemVer**는 LynJS의 버전 정책 표준이다.
- **0.x.x 구간**은 빠른 실험 + 명확한 노트 작성 훈련 기간이다.
- **모노레포**에서는 `"*"`와 Changesets로 관리 복잡도를 줄인다.
- **외부 플러그인**은 항상 `lynjs`를 peer로 의존해 단일 진입점을 공유한다.
