1. **CustomElement 생명주기 이해**

- _왜_: `render()` 호출 타이밍·정리 타이밍 결정
- _결과_: 메모 + 체크리스트(connected / disconnected / attributes)

2. **비어 있는 `LynElement` 골격 생성**

- _왜_: 모든 컴포넌트의 공통 베이스
- _결과_: `render()` 추상 메서드, `update()`, 최초 마운트 제어

3. **`render()` 전략 스케치**

- _왜_: DOM 패치 정책(전체 재그리기 vs 부분 업데이트) 합의
- _결과_: “초기엔 전체 재그리기 → 이후 diff/부분갱신 전환” 결정 문서

4. **테스트 도구 선정 = Vitest**

- _왜_: TDD 루프 정착(빠름/TS 친화/Node-중심)
- _결과_: `vitest` + `@web/test-runner`는 보류(브라우저 E2E는 나중에)

5. **최초 테스트 코드 작성**

- _왜_: `LynElement`의 수명주기/`update()` 계약을 고정
- _결과_: “렌더 1회만 호출”, “disconnect 시 cleanup 호출” 등 스펙 테스트

6. **Astro 통합(초기 연결)**

- _왜_: 실제 문서 사이트에서 컴포넌트 삽입/동작 확인
- _결과_: Astro 섬(Islands)로 커스텀 엘리먼트 로딩

7. **SSR & HMR 이슈 인식 → 해결 전략 확정**

- _왜_: Astro SSR에서 CE는 서버 렌더 불가 → “프리렌더 + 클라이언트 하이드레이트” 전략 필요
- _결과_: `client:only`/`client:load`/`client:visible` 사용 원칙 + HMR 시 상태 보존 방안 메모

8. **JSX 빌드 체인 확립(초안)**

- _왜_: DX 핵심. TS→Babel(JSX transform) → no-bundle 아키텍처
- _결과_: Babel 플러그인/프리셋 배치, 테스트 통과

9. **상태 관리 기본 합의(비데코레이터 버전)**

- _왜_: 데코레이터 이전에 동작 모델을 먼저 고정해야 혼선이 없음
- _결과_: `setState()`/스케줄러/배치 규칙(동기/마이크로태스크) 문서

10. **데코레이터 소개**

- _왜_: 문법적 설탕의 목표와 제약 명확화
- _결과_: @attr / @state의 책임 범위 정의

11. **데코레이터로 상태 관리 설계·구현**

- _왜_: ergonomics 개선 + 반응성 배선
- _결과_: 최소 기능(@state 반응, @attr reflect) 구현 & 테스트

> 핵심 수정 포인트
>
> - **상태 관리(바닐라) → 데코레이터** 순서를 권장합니다. 데코레이터는 기계실(러닝타임 모델)이 굳어진 뒤에 올려야
>   유지보수가 쉬워요.
> - SSR/HMR은 Astro 적용 **직후** 문제를 체감하면서 잡는 게 효율적입니다(6 → 7).

---

# 각 단계의 “완료 기준(Go/No-Go)”

- 1: 수명주기 요약표 1페이지(문서 저장).
- 2: `LynElement`에서 `connectedCallback` 1회 렌더 보장, `disconnected` cleanup 훅 노출.
- 3: 렌더 정책 문서(초기 풀 리렌더 → 후속 diff 전환 계획).
- 4: `vitest run` 통과, `tsconfig`와 함께 CI에 배선.
- 5: `LynElement` 단위테스트 3~5개(마운트/언마운트/업데이트).
- 6: Astro 페이지에 데모 컴포넌트 1개 삽입(빌드/프리뷰 OK).
- 7: SSR에서의 렌더 전략과 HMR 상태보존 메모 작성(결정사항 기록).
- 8: JSX 변환 파이프라인으로 샘플 컴포넌트 빌드 성공.
- 9: 바닐라 상태 모델 테스트 완비(배치 규칙/동기화 규칙 고정).
- 10: 데코레이터 문서(목표/제약/주의).
- 11: @state/@attr 최소기능 + 테스트 통과.
