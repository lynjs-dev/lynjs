# Vitest로 LynElement unit test 하기

프레임워크나 라이브러리 개발에서 테스트 자동화는 선택이 아니라 필수다. 코드가 커질수록 눈으로만 확인하기는 어려워지고,
작은 수정 하나가 의도치 않은 버그를 불러올 수 있다. 자동화된 테스트는 이런 문제를 조기에 잡아내고, 리팩터링이나 기능
추가 시에도 안정성을 유지할 수 있게 해준다.

자동화된 테스트는 수동 확인 대신, 실행만 하면 결과를 보장해주는 최소한의 안전망이다.

## UI 프레임워크에서 테스트의 중요성

UI 프레임워크는 DOM과 직접 맞닿아 동작한다.

- 버튼 클릭, 속성 반영, 스타일 적용, 생명주기 훅 실행 등 **사용자 환경에서 반드시 정상 동작해야 하는 동작들**이 많다.
- 하지만 브라우저마다 동작이 다르거나, DOM 업데이트 순서가 꼬이는 등 **눈에 보이지 않는 복잡성**도 존재한다.

이때 자동화된 테스트는 단순한 기능 확인을 넘어서:

- **브라우저 환경을 모사**하고,
- **생명주기/렌더링 로직을 검증**하며,
- **앞으로의 변경에도 안정성을 보장**한다.

LynElement 같은 베이스 컴포넌트를 만들었다면, 이제는 그것을 기반으로 **테스트 코드로 안정성을 확보하는 과정**이
필요하다. node.js 생태계에는 Jest, Mocha, Jasmine 같은 다양한 테스트 도구가 있다. 그중 **Vitest**를 하려고 한다.

## 테스트 도구 선택: Vitest

Node.js 생태계에는 Jest, Mocha, Jasmine 같은 다양한 테스트 도구가 있다. LynJS 프로젝트에서는 다음과 같은 이유로
**Vitest**를 선택했다.

1. **문서 환경과의 일관성:** LynJS 자체는 특정 빌드 도구에 의존하지 않지만, 프로젝트 문서는 **Astro + Starlight**로
   작성한다. Astro는 내부적으로 Vite를 기반으로 동작한다. 따라서 문서에서 LynJS 샘플을 직접 실행하고 테스트하는 흐름을
   고려하면, 같은 Vite 기반의 테스트 도구인 Vitest를 쓰는 것이 가장 자연스럽다.

2. **브라우저 기반 테스트 지원:** LynElement는 `HTMLElement`를 상속하기 때문에, DOM과 생명주기 훅(`connectedCallback`,
   `disconnectedCallback`)을 올바르게 검증하려면 **실제 브라우저 환경**에서 테스트를 실행해야 한다. Vitest는
   `--environment happy-dom`이나 `--environment jsdom` 같은 옵션도 제공하지만, Custom Element의 생명주기를 완전히
   검증하기에는 한계가 있다. Vitest의 **브라우저 모드**는 `--browser` 옵션을 통해 실제 브라우저에서 테스트를 실행할 수
   있어 이 문제를 해결해준다.

3. **빠른 실행 속도와 Jest 호환성:** Vitest는 ESM 기반으로 가볍고 빠르게 동작하며, Jest와 유사한 API(`describe`, `it`,
   `expect`)를 제공한다. 덕분에 학습 비용이 적고, 기존 Jest 예제나 문서도 쉽게 참고할 수 있다.

LynJS는 빌드 도구에 구애받지 않지만, **브라우저 기반 테스트가 필요한 특성과 문서 작성·샘플 실행 흐름**을 고려했을 때
Vitest가 가장 적합하다.

## Vitest 기본 설치 방법

`core` 패키지로 이동해 필요한 패키지를 개발 의존성으로 설치한다.

```bash
cd packages/core
npm i -D vitest @vitest/browser playwright @testing-library/dom
```

- **`vitest`**: 테스트 러너. Node 환경과 브라우저 환경에서 테스트를 실행할 수 있다.
- **`@vitest/browser`**: Vitest의 브라우저 모드 지원 패키지. 실제 브라우저(Chromium/Firefox/WebKit)를 띄워 테스트를
  실행할 수 있다.
- **`playwright`**: 크로스 브라우저 자동화 도구. Vitest 브라우저 모드가 내부적으로 사용하는 런타임으로,
  Chromium/Firefox/WebKit 환경을 제공한다.
- **`@testing-library/dom`**: DOM 조작과 검증을 돕는 유틸리티. 엘리먼트를 쿼리하고 사용자 상호작용(클릭, 입력 등)을
  시뮬레이션할 수 있다.

## Vitest 브라우저 환경 설정

`LynElement`는 단순한 클래스가 아니라 **브라우저의 DOM 환경에서 동작하는 Custom Element**다. 따라서 Node.js 환경에서만
돌리는 테스트로는 `connectedCallback`, `disconnectedCallback` 같은 **생명주기 훅**을 완전히 검증할 수 없다. 이 문제를
해결하기 위해 Vitest의 **브라우저 모드**를 설정한다.

`packages/core/vitest.config.ts` 파일을 생성한다.

```ts
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    browser: {
      enabled: true, // Vitest browser mode 활성화
      headless: true, // 브라우저를 headless 모드로 실행
      provider: 'playwright',
      instances: [
        { browser: 'chromium' },
        // 필요 시 추가: { browser: 'firefox' }, { browser: 'webkit' }
      ],
    },
    testTimeout: 30_000, // 브라우저 초기화/렌더링 지연 대비
  },
});
```

- `browser.enabled`: Node 대신 실제 브라우저에서 테스트를 실행하도록 설정
- `browser.provider`: 브라우저 런타임 제공자. 기본은 `playwright`
- `browser.instances`: 어떤 브라우저에서 테스트할지 지정 (`chromium`, `firefox`, `webkit`)
- `testTimeout`: 브라우저 초기화나 DOM 조작 테스트는 시간이 걸릴 수 있어 기본값보다 늘려주는 것이 안정적

## 테스트 실행 스크립트 추가

core 패키지와 루트 패키지 모두에 스크립트를 추가해 편리하게 실행할 수 있다.

**packages/core/package.json**

```json
{
  "scripts": {
    "test": "vitest",
    "test:watch": "vitest --watch",
    "test:browser": "vitest --browser"
  }
}
```

**package.json (루트)**

```json
{
  "scripts": {
    "test:core": "npm --prefix packages/core run test",
    "test:core:watch": "npm --prefix packages/core run test:watch",
    "test:core:browser": "npm --prefix packages/core run test:browser"
  }
}
```

## 테스트 실행 방법

```bash
# Node 환경에서 실행 (빠른 단위 테스트용)
npm run test:core

# 실제 브라우저 기반으로 실행 (Custom Element 생명주기 검증용)
npm run test:core:browser
```

이제 LynElement 같은 DOM 의존도가 강한 컴포넌트도 **실제 브라우저 환경에서 정확히 검증**할 수 있다.

## LynElement 다시 보기

### LynElement의 핵심 구조 요약

이전에 만든 **LynElement**는 LynJS에서 모든 커스텀 엘리먼트가 상속받게 되는 **기본 베이스 클래스**다. 아직은 특별한
기능을 강제하지 않고, 단 하나의 메서드만 제공하고 있다.

```ts
export class LynElement extends HTMLElement {
  render(): Node {
    return null;
  }
}
```

- `HTMLElement`를 상속해 브라우저가 인식할 수 있는 표준 Custom Element 형태를 따르고 있다.
- `render()`는 모든 컴포넌트가 구현해야 하는 **표준 인터페이스** 역할을 한다.
- 지금은 아무 동작을 하지 않지만, 이후에 상태 관리, 속성 반영, 이벤트 시스템 등을 확장해도 **일관성을 유지**할 수 있는
  기반이 된다.

LynElement는 "**모든 컴포넌트의 공통 뼈대**"로 존재한다.

### Custom Element와의 관계 정리

브라우저에서 제공하는 `CustomElementRegistry.define()`를 통해, LynElement를 상속한 클래스는 실제 HTML 태그처럼 사용할 수
있다.

```ts
class MyButton extends LynElement {
  render() {
    const buttonEl = document.createElement('button');
    buttonEl.innerText = 'Hello Button';
    return buttonEl;
  }
}

customElements.define('my-button', MyButton);
```

이제 HTML 안에서 이렇게 쓸 수 있다:

```html
<my-button></my-button>
```

요약:

- LynElement는 **HTML 표준 Custom Element**를 기반으로 한다.
- 이 베이스를 상속한 모든 컴포넌트는 브라우저 환경에서 태그로 사용할 수 있다.
- 따라서 LynElement를 테스트한다는 건 곧 **Custom Element의 기본 동작과 일관성을 보장**한다는 의미다.

## 첫 번째 테스트 작성

테스트는 “**가장 작은 성공**”부터 확인하는 게 좋다. 여기서는 LynElement를 기반으로 **Custom Element 정의 → 생성 → 타입
확인 → render 결과 확인**까지 검증한다.

핵심 포인트는 **Custom Element는 `new` 연산자로 직접 생성할 수 없고**, 반드시 `document.createElement('my-tag')`을 통해
만들어야 한다는 점이다.

### 파일 구조 제안

```text
packages/core/
  src/
    lyn-element.ts
  test/
    lyn-element.define.test.ts
```

### 테스트 항목

- **정의/업그레이드 확인** `customElements.define(tag, XTestEl)` 후 `document.createElement(tag)`로 생성했을 때 올바르게
  업그레이드되는지 확인한다.
- **타입 확인** 생성된 엘리먼트가 `LynElement`이자 `HTMLElement` 계열인지 검사한다.
- **렌더링 확인** `render()`가 반환한 내용이 Shadow DOM에 올바르게 반영되는지 검증한다.

### 테스트 코드

**packages/core/test/lyn-element.define.test.ts**

```ts
import { describe, it, expect, beforeAll } from 'vitest';
import { LynElement } from '@lynjs/core';

describe('LynElement - define', () => {
  const tag = 'x-test-define-lyn-element';

  beforeAll(() => {
    class XTestEl extends LynElement {
      connectedCallback() {
        if (!this.shadowRoot) {
          this.attachShadow({ mode: 'open' });
        }
        const el = this.render();
        if (el) this.shadowRoot!.appendChild(el);
      }

      protected render() {
        const el = document.createElement('div');
        el.textContent = 'Hello World';
        return el;
      }
    }

    if (!customElements.get(tag)) {
      customElements.define(tag, XTestEl);
    }
  });

  it('should create element via document.createElement and upgrade to LynElement', () => {
    const el = document.createElement(tag);
    expect(el).toBeInstanceOf(LynElement);
    expect(el).toBeInstanceOf(HTMLElement);
  });

  it('should render the content inside shadowRoot', () => {
    const el = document.createElement(tag) as LynElement;
    const div = el.shadowRoot?.querySelector('div');
    expect(div?.textContent).toBe('Hello World');
  });
});
```

- `customElements.define(tag, XTestEl)` → 브라우저에 `x-test-define-lyn-element` 태그를 등록한다.
- `document.createElement(tag)` → 단순한 HTMLElement가 아니라 **XTestEl** 클래스로 업그레이드된 인스턴스를 반환한다.
- `expect(el).toBeInstanceOf(LynElement)` → LynJS 베이스 클래스에 속하는지 확인한다.
- `expect(el).toBeInstanceOf(HTMLElement)` → 표준 HTML 요소 계층도 따른다는 것을 검증한다.
- Shadow DOM을 붙이고 `render()` 반환값을 삽입하도록 구현했으므로, `shadowRoot.querySelector('div')`를 통해 **렌더링
  결과**를 직접 확인할 수 있다.

이 테스트를 통해 LynElement 기반 컴포넌트가 **Custom Element 스펙에 맞게 정의되고 업그레이드되는지**, 그리고 `render()`
결과가 Shadow DOM에 정상 반영되는지 보장할 수 있다.
