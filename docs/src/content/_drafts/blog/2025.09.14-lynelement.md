# LynElement — 최소 스펙 (현재 단계)

객체 지향 방식으로 프레임워크를 설계할 때는 모든 컴포넌트가 공통적으로 따라야 하는 **수명주기, 계약, 확장 포인트**를 한 곳에 모아둔 베이스 클래스가 필요하다.
이 베이스가 있어야 이후에 기능을 확장할 때 일관성을 유지하고, 프레임워크 차원에서 새로운 철학(예: 리액티비티, SSR, 렌더링 정책)을 자연스럽게 얹을 수 있다.

LynJS에서는 그 역할을 맡는 클래스가 바로 `LynElement`다. 모든 커스텀 엘리먼트는 이 클래스를 상속받아 만들어지며, 여기서부터 LynJS의 철학이 점진적으로 구현된다.

`LynElement`는 LynJS에서 **모든 Custom Element의 공통 베이스**가 된다.
지금은 **아무 동작도 강제하지 않는 껍데기**이며, 오직 `render()`만 제공한다.

## 목표

- **HTMLElement를 상속한 비어 있는 베이스 클래스**를 `@lynjs/core`에 만들고, **`render()` 메서드까지만** 정의한다.
- 여기서부터 LynJS 철학(플랫폼 친화, 객체지향 리액티비티, HMR/SSR 등)을 **점진적으로 얹어갈 예정**이다.

---

## 코드

### `packages/core/src/lyn-element.ts`

```ts
// 최소 스펙: HTMLElement 상속 + render()만 제공
// - render(): Node를 리턴
// - constructor에서 render()를 호출해 root에 1회 추가
// - root는 static useShadow 여부에 따라 shadowRoot 또는 자신(this)
export class LynElement extends HTMLElement {
  /**
   * 컴포넌트 루트 선택: shadow를 쓸지 여부.
   * true면 open shadow root를 생성해 사용한다.
   */
  static useShadow = true;

  /** 현재 컴포넌트가 그릴 루트. shadow 사용 시 shadowRoot, 아니면 this */
  protected get root(): ParentNode & Node {
    const Class = this.constructor as typeof LynElement;
    if (Class.useShadow) {
      // 최초 접근 시 shadowRoot가 없다면 생성
      return (this.shadowRoot ?? this.attachShadow({ mode: 'open' })) as unknown as ParentNode & Node;
    }
    return this as unknown as ParentNode & Node;
  }

  constructor() {
    super();
    // useShadow가 true면 미리 생성해 둔다(초기 렌더 대상 보장)
    if ((this.constructor as typeof LynElement).useShadow && !this.shadowRoot) {
      this.attachShadow({ mode: 'open' });
    }
    // 초기 렌더 결과를 루트에 부착 (1회)
    const node = this.render();
    if (node) this.root.appendChild(node);
  }

  /**
   * 서브클래스가 오버라이드해 Node를 반환한다.
   * 기본 구현은 빈 텍스트 노드를 반환(no-op에 가깝게 유지).
   */
  protected render(): Node {
    return document.createTextNode('');
  }
}
```

### `packages/core/src/index.ts`

```ts
export { LynElement } from './lyn-element';
```

## 단순하게 시작하는 이유

- **가까운 플랫폼**: 먼저 `HTMLElement` 상속으로 표준 수명주기를 그대로 가진다.
- **확장 포인트 확보**: 불필요한 마법 없이 `render()`만 열어두면, 이후 정책(스케줄/템플릿/리액티비티)을 **명시적으로 주입**하기 쉽다.
- **점진적 설계**: 실제 철학(객체지향 리액티비티, HMR/SSR)은 다음 단계에서 안전하게 추가한다.
