# NPM 자동 배포하기

`npm version patch && npm publish` 명령어를 직접 실행하는 방식은 초기에는 간단하지만, 협업이 늘어나고 릴리스 주기가
짧아질수록 실수 가능성이 커진다.

- 배포 이력 관리가 불명확하다.
- 로컬 환경 차이로 인해 배포 실패 또는 의도치 않은 파일 포함 가능성이 있다.
- 테스트를 건너뛴 채 배포하면 불안정한 버전이 배포될 수 있다.

이러한 문제를 방지하기 위해 **GitHub Actions 등 CI 파이프라인에서 자동으로 npm 배포**를 구성하는 것이 효과적이다.

자동화의 주요 장점:

- 태그 또는 브랜치 푸시만으로 배포가 완료됨
- 테스트 미통과 시 배포 차단
- 프리릴리스(`next`)와 정식(`latest`) 채널 분리로 안정성 확보

자동 배포를 통해 **안정적이고 투명한 배포 사이클**을 유지할 수 있다.

## 목표

목표는 **최소한의 수작업으로 안전하게 npm 배포가 자동화**되는 환경을 구축하는 것이다. **태그 또는 브랜치 푸시 → 테스트
통과 → 버전/릴리스/배포 자동화**가 최종 상태다.

- **태그 기반 원클릭 배포**
  - `vX.Y.Z` 태그 푸시 시 `latest` 채널 자동 배포
  - `vX.Y.Z-next.N` 태그 푸시 시 `next` 채널 자동 배포
- **CI 필수 게이트**
  - 테스트/빌드 실패 시 **배포 차단**
  - 커밋 메시지는 **Conventional Commits**로 강제(commitlint)
- **투명한 릴리스 로그**
  - `CHANGELOG.md` 자동 갱신
  - GitHub Release 자동 생성(아티팩트 첨부 가능)
- **배포 파일 컨트롤**
  - `npm pack --dry-run`으로 포함 파일 사전 검증
  - `files` 또는 `.npmignore`로 포함 파일 최소화
- **프리릴리스 운영 루틴 확보**
  - 기능은 `next` 채널로 조기 배포/검증 후, 안정화 시 `latest` 승격
- **모노레포 확장 여지**
  - 현재는 루트 패키지 1개 기준
  - 향후 패키지 증가 시 **Changesets/semantic-release**로 확장 가능

**빠른 사용 예**

```bash
# 프리릴리스(next 채널)
npm run release:next
# → v0.1.0-next.0 태그 생성 및 푸시
# → CI에서 next 채널로 배포

# 정식 릴리스(latest 채널)
npm run release:patch   # 또는 :minor / :major
# → v0.1.0 태그 생성 및 푸시
# → CI에서 latest 채널로 배포
```

**커밋 메시지 규칙 준수 및 PR 머지 또는 태그 푸시**만으로 CI가 릴리스 전체를 자동 처리한다. 릴리스는 기록 가능하고, 재현
가능하며, 안전하게 이루어진다.

## 자동 배포의 필요성

- **휴먼 에러 감소:** 로컬에서 버전 업데이트 및 `npm publish` 등 수작업은 실수 가능성이 높다. CI에서 태그/브랜치
  이벤트로 자동 처리한다.
- **일관된 릴리스 프로세스:** 테스트, 빌드, 버전/체인지로그 생성, 배포까지 일관된 파이프라인으로 관리된다.
- **권한/보안 분리:** 개인 PC 토큰 없이, GitHub 시크릿과 npm **Automation Token**을 활용하여 안전하게 배포한다.

## 자동 배포 방법에는 무엇이 있나?

자동 배포에는 여러 접근 방식이 있으며, 프로젝트 상황에 따라 적합한 방법을 선택할 수 있다.

### A안 - 단일 패키지(또는 루트 패키지) 자동 배포

- 태그(`v0.1.0`) 푸시 시 CI가 자동으로 배포한다.
- 프리릴리스 태그(`v0.1.0-next.0`)는 `next` 채널, 정식 태그(`v0.1.0`)는 `latest` 채널로 구분된다.
- 단일 루트 패키지 배포에 적합하다.
- 설정이 단순하고 러닝커브가 낮다.

### B안 - 모노레포(여러 패키지) 자동 배포

- `packages/*` 내 여러 패키지를 각각 버전 관리/배포해야 하는 경우 **Changesets** 사용이 적합하다.
- PR마다 변경 내용을 기록하고, 태그 생성 시 변경된 패키지들만 자동 배포된다.
- 대규모 모노레포에 적합하다.
- 단일 패키지 배포에는 과도한 설정일 수 있다.

### C안 - semantic-release

- 커밋 메시지를 분석하여 버전 증가, 릴리스 노트 작성, GitHub Release, npm 배포를 자동화한다.
- 팀 전체가 **Conventional Commits**를 준수할 때 효과적이다.
- 완전 자동화 가능하나, 설정 난이도가 있다.

## 왜 semantic-release 인가?

단일 패키지 자동 배포(A안) 및 모노레포 자동 배포(B안)도 상황에 따라 적합하다. 그러나 LynJS는 버전 관리 자동화, CHANGELOG
및 릴리스 노트 자동화, 채널 분리, 장기적 확장성까지 고려하여 semantic-release(C안)를 선택한다.

semantic-release 선택 이유:

- **버전 증가 자동화:** 커밋 메시지를 기준으로 버전이 자동 계산되어 수동 개입 최소화
- **CHANGELOG와 릴리스 노트 자동 관리:** Conventional Commits 기반으로 `CHANGELOG.md`와 GitHub Release 노트 자동 생성
- **채널 분리 용이:** `main` → `latest`, `next` → `next` 채널로 자동 배포
- **확장성:** 단일 패키지에서 모노레포로 전환 시에도 플러그인 구성을 통해 확장 가능

즉, 커밋 메시지 규칙만 준수하면 릴리스·배포가 자동화된다.

## semantic-release가 하는 일

semantic-release는 버전 증가, 태그 생성, 릴리스 노트 작성, npm publish 등 릴리스 전 과정을 **커밋 메시지 규칙** 에 따라
자동 처리한다.

- **커밋 → 버전 자동 결정**
  - `fix:` → PATCH
  - `feat:` → MINOR
  - `feat!:` 또는 본문에 `BREAKING CHANGE:` → MAJOR
- **브랜치 머지 시 자동 처리**
  - `main` 또는 `next` 브랜치에 머지되면 버전 계산, CHANGELOG 생성, GitHub Release, npm 배포가 자동으로 진행된다.
- **채널 분리 자동화**
  - `main` 브랜치 → `latest`
  - `next` 브랜치 → `next`(프리릴리스)

semantic-release는 릴리스 매니저 역할을 하며, 개발자는 Conventional Commits 규칙에 맞는 커밋 메시지 작성만 준수하면
된다.

## semantic-release 설정

현재는 루트 패키지 `lynjs` 하나만 배포(모노레포 구조이나 단일 패키지 배포 구성)

### 필수 토큰 준비

semantic-release 동작에 필요한 토큰:

- npm 배포용 **npm Granular Access Token**
- GitHub Release, 태그 푸시 등에 필요한 **GITHUB_TOKEN**

**npm Granular Access Token**

- `@semantic-release/npm` 플러그인에서 npm 레지스트리 인증에 사용
- 발급 방법:
  1. [npmjs.com → 계정 Settings → Access Tokens](https://www.npmjs.com/settings)
  2. "Generate New Token" 클릭
  3. Granular Access Token 타입 선택
  4. 생성된 토큰을 복사
  5. GitHub 저장소 → Settings → Secrets and variables → Actions → New repository secret
  - 이름: `NPM_TOKEN`
  - 값: 발급받은 토큰 문자열

_토큰은 한 번만 확인 가능하며, 유출 시 즉시 revoke 필요_

**GITHUB_TOKEN**

- GitHub Actions 워크플로우 실행 시 자동 발급되는 단기 토큰
- `@semantic-release/github`, `@semantic-release/git` 플러그인에서 사용(GitHub Release 생성, 태그 푸시, 파일 커밋 등)
- 별도 발급 없이 `${{ secrets.GITHUB_TOKEN }}` 환경변수 사용

**권한 설정**

- semantic-release가 릴리스/태그/커밋 작업을 수행하려면 write 권한 필요
- 워크플로우 파일 상단에 다음 설정 필요

```yaml
permissions:
  contents: write # 릴리스, 태그, 커밋
  issues: write # (옵션) 릴리스 결과 코멘트
  pull-requests: write # (옵션) PR에 코멘트 남길 때
```

- 저장소 Settings → Actions → General → Workflow permissions에서 **Read and write permissions** 활성화 필요

### 작업 브랜치 생성

자동 배포에서는 `main`을 안정(stable, `latest`) 채널, `next`를 프리릴리스(pre-release, `next`) 채널로 사용한다. 새로운
기능이나 실험적 변경은 `next`에서 먼저 배포 및 검증 후, 안정화 시점에 `main`으로 병합하여 정식 릴리스로 승격한다.

`v0.0.1` 태그를 기준으로 `next` 브랜치를 생성하고, 실제 작업은 별도의 기능 브랜치에서 진행 후 `next`에 병합한다.

```bash
# v0.0.1 태그에서 next 브랜치 생성
git checkout -b next v0.0.1
git push origin next

# 작업용 브랜치 생성 (예: CI 자동 배포 세팅)
git checkout -b feature/ci-npm-setup
git push origin feature/ci-npm-setup
```

- **next 브랜치**
  - 출발점: `v0.0.1` 태그
  - semantic-release에 의해 `0.0.x-next.y` 형태의 프리릴리스 버전 자동 배포
- **작업 브랜치(feature/ci-npm-setup)**
  - CI 설정이나 기능 개발을 위한 임시 브랜치
  - 작업이 끝나면 PR을 통해 `next`로 병합 → 프리릴리스 배포
- **main 브랜치**
  - 안정화가 끝난 시점에 `next`를 병합
  - 이때 자동으로 정식(`latest`) 릴리스가 배포된다

### 의존성 설치

semantic-release는 본체만 설치해도 동작하긴 하지만, 실제로 “버전 계산 → 노트 생성 → CHANGELOG 업데이트 → GitHub Release
→ npm 배포”까지 풀 체인을 자동화하려면 여러 플러그인을 함께 사용해야 한다.

```bash
npm i -D semantic-release \
  @semantic-release/commit-analyzer \
  @semantic-release/release-notes-generator \
  @semantic-release/changelog \
  @semantic-release/npm \
  @semantic-release/github \
  @semantic-release/git \
  @commitlint/cli @commitlint/config-conventional \
  husky
```

- **semantic-release:** “커밋을 읽어서 어떤 버전을 올릴지 결정, 각 플러그인을 순서대로 실행”하는 오케스트레이터 역할.
- **@semantic-release/commit-analyzer:** 커밋을 읽어 **버전 증가량** 결정
- **@semantic-release/release-notes-generator:** 커밋 기반 **릴리스 노트** 생성
- **@semantic-release/changelog:** `CHANGELOG.md` 파일 생성/업데이트
- **@semantic-release/npm:** npm 배포
- **@semantic-release/github:** GitHub Release 생성
- **@semantic-release/git:** `CHANGELOG.md`/`package.json` 등을 **커밋**(선택)
- **husky:** Git 훅을 쉽게 다룰 수 있게 해준다. 보통 commit-msg 훅에서 commitlint를 실행해서, 잘못된 커밋은 아예
  들어가지 못하게 막는다.

> **Husky**는 Git 훅(pre-commit, commit-msg, pre-push 등)을 간단히 관리할 수 있도록 해주는 도구이다. Husky를 사용하면
> 레포 내에서 버전 관리되는 설정으로 훅을 공유할 수 있으며, 커밋 직전에 린트/포맷 등 품질 체크를 자동 실행하여 문제 발생
> 시 커밋을 차단할 수 있다. `git commit --no-verify`로 훅을 일시적으로 우회할 수 있으나, 권장하지 않는다.

### semantic-release 설정 파일

루트에 **`.releaserc.cjs`** 추가:

**.releaserc.cjs**

```ts
const isCI = !!process.env.CI; // GitHub Actions에선 기본 true

module.exports = {
  repositoryUrl: 'git@github.com:lynjs-dev/lynjs.git',
  branches: ['main', { name: 'next', prerelease: true }],
  plugins: [
    [
      '@semantic-release/commit-analyzer',
      {
        preset: 'conventionalcommits',
        releaseRules: [
          { breaking: true, release: 'major' }, // BREAKING CHANGE가 있으면 무조건 major
          { type: 'feat', release: 'minor' }, // 새로운 기능(feat)은 minor
          { type: 'fix', release: 'patch' }, // 버그 수정(fix)은 patch
          { type: 'perf', release: 'patch' }, // 성능 개선(perf)은 patch
          { type: 'refactor', release: false }, // 리팩토링(refactor)은 버전 올리지 않음
          { type: 'revert', release: 'patch' }, // 변경 되돌림(revert)은 patch
          { type: 'test', release: false }, // 테스트 코드만 변경은 버전 올리지 않음
          { type: 'build', release: 'patch' }, // 빌드 설정(build) 변경은 patch
          { type: 'ci', release: false }, // CI 구성 변경(ci)은 버전 올리지 않음
          { type: 'docs', release: false }, // 일반 문서 변경(docs)은 버전 올리지 않음
          { type: 'docs', scope: 'release', release: 'patch' }, // 릴리스 문서(docs/release)는 patch
          { type: 'chore', release: false }, // 일반 작업(chore)은 버전 올리지 않음
          { type: 'chore', scope: 'release', release: 'patch' }, // 릴리스 관련 chore는 patch
        ],
      },
    ],
    ['@semantic-release/release-notes-generator', { preset: 'conventionalcommits' }],

    // === 아래 4개는 CI에서만 실행 ===
    isCI && ['@semantic-release/changelog', { changelogFile: 'CHANGELOG.md' }],
    isCI && ['@semantic-release/npm', { tarballDir: 'dist-tarball' }],
    isCI && ['@semantic-release/github', { assets: 'dist-tarball/*.tgz' }],
    isCI && [
      '@semantic-release/git',
      {
        assets: ['CHANGELOG.md', 'package.json'],
        message: 'chore(release): ${nextRelease.version} [skip ci]\n\n${nextRelease.notes}',
      },
    ],
  ].filter(Boolean),
};
```

- **branches**
  - `main` → 안정 채널(`latest`)
  - `next`(prerelease: true) → 프리릴리스 채널(`next`) + 버전 접미사(`-next.x`)
- **npm 플러그인**
  - `tarballDir`에 배포 아티팩트를 남겨 GitHub Release에 첨부
- **git 플러그인**
  - 릴리스마다 `CHANGELOG.md`와 `package.json`을 커밋(선택 기능, 투명성 ↑)

> 원치 않으면 `@semantic-release/git`에서 `package.json`을 빼도 된다. (semantic-release는 **커밋 없이도** npm에 최신
> 버전으로 배포 가능)

### Conventional Commits 강제(권장)

`commitlint + husky`로 커밋 규칙을 강제한다.

#### commitlint 설정

**`commitlint.config.cjs`**

```js
module.exports = {
  extends: ['@commitlint/config-conventional'],
};
```

#### husky 초기화 & 훅 추가

```bash
npx husky init
# .husky/pre-commit 에 팀의 기존 린트/테스트가 있다면 유지
# 커밋 메시지 검사 훅 추가
```

**.husky/commit-msg**

```bash
# CI에서는 커밋 메시지 검사 스킵
[ -n "$CI" ] && exit 0
npx --no-install commitlint --edit "$1"
```

> 규칙에 어긋난 커밋 메시지는 커밋 단계에서 차단된다.

### 스크립트 작성

semantic-release는 CLI 형태로 실행되기 때문에 `npx semantic-release`로도 바로 돌릴 수 있다. 하지만 매번 긴 명령어를
입력하는 대신, `package.json`의 `scripts`에 짧게 등록해두면 CI나 로컬에서 실행할 때 편하다.

**package.json**

```json
{
  "scripts": {
    "release": "semantic-release"
  }
}
```

- **release:** semantic-release 실행 스크립트. CI/CD에서 릴리스를 트리거할 때 사용

**--dry-run 옵션:** semantic-release가 실제로 어떤 버전 증가, CHANGELOG, 릴리스, 배포를 수행할지 미리 확인하려면
`--dry-run` 옵션을 사용한다.

실행 예시:

```bash
npm run semantic-release -- --dry-run
```

### GitHub Actions 워크플로우

태그 트리거가 아니라 **브랜치 푸시**를 트리거로 쓰는 게 semantic-release 정석이다. semantic-release가 **직접
버전/태그/릴리스**를 만든다.

**.github/workflows/release.yml**

```yaml
name: Release (semantic-release)

on:
  push:
    branches: [main, next] # 브랜치 기반 트리거
  workflow_dispatch: {}

permissions:
  contents: write # 릴리스/태그 작성
  issues: write # (옵션) 릴리스 결과 코멘트 등
  pull-requests: write

jobs:
  release:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # 전체 히스토리(모든 커밋)을 가져옴. 커밋/태그 이력 필요
          fetch-tags: true # 원격 태그까지 함께 받아옴. 이전 태그 히스토리 필요

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm
          registry-url: 'https://registry.npmjs.org'

      - name: Install
        run: npm ci

      # (옵션) 테스트/빌드
      # - name: Test
      #   run: npm test
      # - name: Build
      #   run: npm run build

      - name: Configure npm auth
        run: echo "//registry.npmjs.org/:_authToken=${NPM_TOKEN}" > ~/.npmrc
        env:
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
          # HUSKY: 0   # CI에서 HUSKY 훅 비활성화(충돌 방지)
        run: npm run release
```

- `main`에 머지 → `latest`로 배포
- `next`에 머지 → `next`로 프리릴리스 배포
- `GITHUB_TOKEN`/`NPM_TOKEN` 환경변수로 인증 처리

### 첫 실행 체크 (Dry Run)

실제 배포 전, 로컬에서 다음과 같이 동작 예측이 가능하다.

```bash
npx semantic-release --dry-run
```

어떤 버전 증가, 릴리스 노트, 배포 채널이 적용될지 로그로 확인할 수 있다.

## 프리릴리스 배포 흐름

자동 배포 환경에서는 직접 `npm publish`를 실행하지 않는다. 커밋 → PR → `next` 병합 → CI 과정을 거치면 semantic-release가
버전 계산 및 프리릴리스(`next` 채널) 배포를 자동으로 수행한다.

### 1. 작업 브랜치에서 커밋

기능 추가나 설정 변경사항을 작업 브랜치에 커밋한다. 커밋 메시지는 **Conventional Commits 규칙**을 따라야 버전이 올바르게
계산된다.

```bash
git add .
git commit -m "feat: add initial semantic-release setup"
git push origin feature/ci-npm-setup
```

### 2. Pull Request 생성

- 작업 브랜치에서 `next`로 PR을 생성한다.
- 리뷰 및 테스트 통과 시 머지한다.

### 3. next 브랜치 병합 → 자동 배포

- PR 머지 시 GitHub Actions가 실행된다.
- semantic-release가 커밋 로그를 분석하여 `0.0.x-next.y` 버전을 계산한다.
- CHANGELOG.md 업데이트, 태그 생성, GitHub Release, npm `next` 채널 배포가 자동 처리된다.

### 4. main 브랜치로 승격

- 안정화된 시점에 `next` 브랜치를 `main`에 병합한다.
- 이때 프리릴리스가 아닌 **정식 릴리스(`latest`)**로 배포된다.

### 운영 루틴

- **작업 브랜치 → PR → main/next 머지**
- 머지 시 CI가 자동으로 다음을 수행:
  1. 커밋 분석 및 버전 결정
  2. CHANGELOG 갱신
  3. Git 태그 및 GitHub Release
  4. npm publish (`main`→`latest`, `next`→`next`)
- 커밋 메시지 규칙 준수 및 PR 머지만 수행하면 된다.

## 활용 방법

활용 팁:

- **브랜치 보호 규칙:** `main`/`next`에 CI 필수 체크를 적용하여 불완전한 릴리스 차단
- **문서 연동:** 릴리스에 맞춰 문서 빌드/배포 워크플로우 후속 작업으로 연동
- **패치/핫픽스:** `fix: ...` 등으로 작은 PR을 `main`에 바로 머지하여 자동 패치 릴리스 가능
- **프리릴리스 검증:** 새로운 기능은 `next`에 먼저 배포하여 일부 사용자가 미리 검증, 안정화 후 `main`으로 승격
- **문제 상황 대응**
  - 버전 미증가: 커밋 타입이 `feat`, `fix`, `BREAKING CHANGE` 계열인지 확인
  - npm 권한 오류: Automation Token, 스코프 권한, `publishConfig.access: public` 설정 점검
  - CHANGELOG 미생성: `.releaserc.json`에 `@semantic-release/changelog`/ `@semantic-release/git` 포함 여부 확인

semantic-release는 커밋 규칙만 준수하면 버전, 릴리스, 배포를 자동 처리한다. 단일 패키지 배포 단계에서도 도입 가치가
충분하며, 다중 패키지로 확장 시에도 철학을 유지할 수 있다.

잘못 배포된 경우 복구 방법을 아래에 정리한다.

## 잘못된 릴리스/태그 복구 방법

### 원격 태그 삭제

```bash
# 로컬 및 원격 태그 동시 삭제
git tag -d v1.0.0-next.5
git push origin :refs/tags/v1.0.0-next.5
```

### GitHub Release와 태그 동시 삭제

```bash
# gh CLI 사용 시
gh release delete v1.0.0-next.5 -y --cleanup-tag
```

### 다수 태그 일괄 삭제

```bash
git fetch --tags
git tag -l 'v1.0.0-next.*' | xargs -n1 -I {} git push origin :refs/tags/{}
git tag -l 'v1.0.0-next.*' | xargs -n1 git tag -d
```

_semantic-release는 Git 태그를 기준으로 이전 릴리스를 판단하므로, 액션의 checkout 스텝에서 `fetch-depth: 0`,
`fetch-tags: true`를 유지해야 한다._

## npm에 잘못 배포된 특정 버전 삭제/차단

### 배포 24시간 이내: 삭제 가능

```bash
npm unpublish <패키지>@<버전>
# 예시: npm unpublish @moe.js/test-project@1.0.0-next.5
```

### 24시간 경과 후: deprecate로 차단

```bash
npm deprecate <패키지>@<버전> "⚠️ 잘못된 릴리스입니다. 새 버전을 사용하세요."
# 예시: npm deprecate @moe.js/test-project@1.0.0-next.5 "broken: use 1.0.0-next.6+"
```

### dist-tag 수정 (latest/next 잘못 지정 시)

```bash
# 잘못된 태그 제거
npm dist-tag rm <패키지> latest
# 올바른 버전으로 재지정
npm dist-tag add <패키지>@<버전> latest

# 예시: next 채널 교체
npm dist-tag rm @moe.js/test-project next
npm dist-tag add @moe.js/test-project@1.0.0-next.6 next
```

_이미 배포된 버전은 같은 번호로 다시 배포 불가. 삭제 가능 시간(24시간) 경과 시 deprecate 후 새로운 버전 재배포로
처리한다._

## npm에서 프로젝트 전체 삭제 (최후의 수단)

```bash
npm unpublish <패키지> --force
# 예시: npm unpublish @test.js/test-project --force
```

- 24시간 동안 동일 이름으로 패키지 재배포 불가
- 모든 버전이 완전히 삭제됨(복구 불가)
- 동일 이름을 다른 사용자가 등록할 수 있으므로 즉시 재배포 필요
- 공개 패키지에 의존하는 프로젝트가 있을 경우 권장하지 않음

## 버전 라인 재정렬(0.x부터 재시작)

### Git 태그 재설정 (예: `v0.0.1`부터 시작)

```bash
git checkout next   # 또는 main
git pull --rebase
git tag -a v0.0.1 -m "baseline: start from v0.0.1"
git push origin v0.0.1
```

### 액션에서 태그를 인식하도록 설정

```yaml
- uses: actions/checkout@v4
  with:
    fetch-depth: 0
    fetch-tags: true
```

### 이후 커밋 타입에 따라 버전 증가

- `fix:` → `0.0.2[-next.0]`
- `feat:` → `0.1.0[-next.0]`

_참고: package.json의 version 필드는 기준이 아니며, semantic-release는 Git 태그만을 기준으로 이전 릴리스를 계산한다._

## 상태 점검 명령어

```bash
# npm 관련
npm view <패키지> versions --json
npm view <패키지> dist-tags

# git 태그 관련
git fetch --tags
git tag --list | sort -V
```

## 사고 예방을 위한 권장 사항

- 액션에서 `fetch-depth: 0` 및 `fetch-tags: true` 설정 필수
- 릴리스 전 로컬에서 dry-run 수행
  ```bash
  npx semantic-release --dry-run
  ```
- commitlint 및 husky로 커밋 타입 강제
- 실수로 인한 태그 푸시 배포 방지를 위해 태그 트리거가 아닌 브랜치 푸시 기반 배포 운영 권장
