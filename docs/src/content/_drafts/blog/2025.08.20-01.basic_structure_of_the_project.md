# 프로젝트 구조

새로운 프레임워크를 만들겠다고 마음먹었을 때, 나는 가장 먼저 이런 질문을 스스로에게 던졌다.
“어디서부터 시작해야 할까?”

프레임워크의 본질적인 기능을 구현하는 것도 중요하지만, 그 이전에 반드시 필요한 것이 있다고 생각했다.
바로, 앞으로의 모든 작업을 담아낼 도화지 같은 프로젝트의 형태다.

아직 LynJS는 개발되지 않았다.
지금 나는 그저 “이 프레임워크를 어떤 프로젝트 구조 위에서 시작해야 하는가”라는 고민을 하고 있는 단계다.
이 선택이 단순히 시작점에 불과한 것처럼 보일 수 있지만, 사실은 이후의 모든 개발 과정에 깊게 영향을 미칠 결정이다.
잘못된 선택을 하면 나중에 돌아와 고쳐야 하고, 그 과정에서 불필요한 에너지가 낭비될 수도 있다.

그래서 나는 지금,
프로젝트를 어떤 구조로 가져갈지
어떤 도구를 함께 사용해야 할지
문서화를 어떻게 끌고 갈지
이 세 가지를 집중적으로 고민하고 있다.

그리고 그 과정에서 내린 첫 번째 결론은, **“도화지로서의 프로젝트부터 만들어야 한다”**는 것이다.
이 도화지는 단순한 파일 몇 개가 아니라, 앞으로 LynJS라는 프레임워크를 그려나갈 토대가 될 것이다.

## 프로젝트 구조의 선택

### 왜 프로젝트 구조가 중요한가?

프레임워크를 개발한다는 건 단순히 기능을 쌓는 일이 아니다.
앞으로 수많은 기능이 추가되고, 다양한 환경에서 테스트되며, 다른 사람들이 함께 기여하게 될 수도 있다.
이 모든 과정을 생각했을 때, 가장 먼저 부딪히는 문제는 바로 프로젝트 구조다.

나는 지금 이런 고민을 하고 있다.
“프로젝트를 어떤 구조로 시작해야, 나중에 불필요한 혼란을 줄일 수 있을까?”
“처음부터 단일 레포지토리로 가는 게 나을까, 아니면 모노레포로 가는 게 나을까?”

프로젝트 구조는 단순히 폴더를 어떻게 나누느냐의 문제가 아니다.

새로운 기능을 어디에 추가할지,

공통된 로직을 어떻게 재사용할지,

문서와 테스트를 어떤 흐름으로 관리할지,

그리고 나중에 다른 개발자들이 합류했을 때 얼마나 쉽게 이해할 수 있을지,

이 모든 것들을 결정짓는 프레임워크의 뼈대다.

잘못된 구조로 출발하면 나중에 발목을 잡는다.
예를 들어, 단일 레포지토리에서 시작했는데 기능이 커지면서 서브 프로젝트가 필요해지면, 그때 가서 모노레포로 옮겨야 한다.
이 과정은 단순한 폴더 이동이 아니라, 빌드 도구와 배포 파이프라인까지 전부 다시 설계해야 하는 큰 부담이 된다.

그래서 나는 지금, 코드 한 줄을 쓰기 전에 프로젝트 구조를 어떻게 가져갈 것인가를 가장 먼저 고민하고 있다.
이 선택이 LynJS의 시작과 끝을 좌우할 것이라 믿기 때문이다.

### 단일 레포 vs 모노레포 비교

프로젝트를 시작할 때 가장 먼저 맞닥뜨리는 고민 중 하나는 저장소 구조다.
지금 내 상황에서는 선택지가 두 가지뿐이다.
단일 레포(single repo)로 시작할 것인가, 아니면 모노레포(monorepo)로 출발할 것인가.

단일 레포는 단순하다.

- 프로젝트 전체가 하나의 패키지로 묶인다.
- 설정이 가볍고 빠르게 시작할 수 있다.
- 작은 라이브러리나 툴에 적합하다.

하지만 프레임워크는 이야기가 다르다. 시간이 지날수록 기능이 커지고, 하위 프로젝트들이 자연스럽게 파생된다.
그럴 때 단일 레포는 점점 관리가 힘들어진다. 모든 것을 한 덩어리로 다루기 때문에, 어디서 무엇이 바뀌었는지 추적하기 어렵고, 공통된 로직과 실험적인 시도가 뒤섞이면서 프로젝트가 무겁게 변한다.

모노레포는 처음에 설정이 다소 무겁다.

- 워크스페이스를 구성하고 빌드·테스트 환경을 공유하도록 세팅해야 한다.
- 단일 레포에 비해 출발선이 조금 더 복잡하다.

하지만 모노레포의 강점은 확장성에 있다.
아직 어떤 서브 프로젝트가 생겨날지 모르더라도, 미리 그 가능성을 열어둘 수 있다.
새로운 기능을 별도의 패키지로 분리해 실험할 수 있고, 공통 도구와 설정을 한 번에 관리할 수 있으며, 나중에 필요하면 독립적으로 배포도 가능하다.

비교 정리

- 단일 레포는 “지금 당장 빨리 시작”하는 데 유리하다.
- 모노레포는 “무엇이 생겨날지 모르는 상황에서도 대비”할 수 있게 한다.

나는 지금 LynJS의 구상 단계에 있다.
아직 어떤 기능이 만들어질지, 어떤 패키지가 필요할지 확실하지 않다.
하지만 이 불확실성 자체가 오히려 모노레포를 선택해야 하는 이유가 된다.
앞으로 무언가 파생될 가능성이 크기 때문에, 그 여지를 초반부터 열어둬야 한다는 것이다.

### 모노레포 구조를 선택한 이유

지금 나는 LynJS를 막 시작선에 세우고 있다. 무엇을 얼마나 만들지, 어떤 하위 프로젝트가 생겨날지조차 아직은 안개 속이다.
그래도 한 가지는 분명하다. 구조는 방향을 만든다. 그래서 나는 초기에 약간의 무게를 감수하더라도 모노레포를 택하려고 한다.

내 논리는 이렇다.

- 미지의 확장을 위한 여백
  처음부터 세부 패키지를 정해두지 않더라도, 모노레포는 “나중에 분화될 무언가”를 자연스럽게 받아들일 여백을 제공한다.
  핵심 로직, 실행 환경, 툴링, 예제/플레이그라운드, 문서화 같은 역할의 층위만 느슨하게 가정해 두고, 실제 패키지 경계는 개발을 진행하며 서서히 드러나게 둔다.

- 결합은 느슨하게, 경계는 선명하게
  모노레포는 한 저장소 안에서 작업하지만, 각 부분을 독립적인 패키지처럼 바라보게 만든다.
  이 덕분에 “여기서 바꾸면 어디가 흔들리는가?”를 의식하며 코드를 쓰게 되고, 초기부터 내부 계약(인터페이스)과 의존 그래프를 건강하게 관리할 수 있다.

- 공통 도구의 단일화
  린터, 포매터, 테스트 러너, 타입 설정, 커밋 규칙 같은 바닥 공사는 한 번 깔고 전 패키지가 공유한다.
  아직 무엇을 만들지 정해지지 않았어도, “개발 경험의 바닥”은 일관되게 가져갈 수 있다. 이것만으로도 추후 분화의 마찰이 크게 줄어든다.

- 실험과 폐기의 비용 최소화
  구상 단계에서는 많이 만들어 보고, 자주 버려야 한다. 모노레포는 실험용 패키지를 곁가지로 붙였다 떼기 쉽다.
  독립 저장소를 매번 만들고 정리하는 번거로움 없이, 실험—검증—폐기의 루프를 짧게 유지할 수 있다.

- 릴리스 전략의 유연성
  당장은 단일 버전으로 움직이더라도, 나중에 패키지별 버전 또는 부분 배포가 필요해질 수 있다.
  모노레포는 이 전환을 비교적 매끄럽게 해준다. 초기에 CI/CD를 얇게 깔아두면 변화 감지(affected) 기반 테스트/빌드도 도입하기 수월하다.

- 문서화와 개발의 동거
  문서는 별도 리포가 아니라 같은 공간(docs/)에서 소스와 함께 달려야 한다.
  API가 바뀌면 문서도 같은 PR에서 바뀌고, 예제 코드와 레퍼런스가 항상 같은 타임라인을 공유한다. 구상 단계일수록 이 동기화가 특히 중요하다.

물론 단점도 인지하고 있다. 초기 설정이 다소 무겁고, 워크스페이스/빌드 파이프라인을 잡는 데 시간이 든다.
하지만 아직 무엇을 만들지 모르는 지금이야말로, 미래의 분화를 전제한 그릇이 필요하다.
나는 지금, 기능보다 그 기능이 자라날 토양을 고르고 있다. 모노레포는 그 토양으로 충분히 설득력이 있다.

### 모노레포가 주는 이점

모노레포를 선택하면 당장 눈앞의 복잡도가 조금은 늘어난다.
하지만 그 복잡도를 감수할 만한 이유가 분명히 있다. 나는 지금 LynJS의 구상 단계에서 이 점들을 특히 크게 보고 있다.

1. 확장의 여지를 남긴다

아직 어떤 서브 프로젝트가 생겨날지 모르지만, 모노레포는 그 가능성을 자연스럽게 품고 있다.
핵심 로직이든, 도구 연동이든, 문서화든… 나중에 필요해지면 언제든 별도의 패키지로 떼어내 관리할 수 있다.
처음부터 “분화될 수 있다”는 가정을 전제로 하는 구조라는 점이 강력하다.

1. 공통 도구의 일관성

린터, 포매터, 타입스크립트 설정, 테스트 러너 같은 기초 도구들은 프로젝트 전반에 걸쳐 공유된다.
여러 패키지가 생기더라도 같은 규칙과 환경 위에서 돌아가기 때문에, 개발자가 늘어나도 일관성을 유지하기 쉽다.

1. 실험과 폐기의 유연성

구상 단계에서는 많은 시도를 하게 된다.
아이디어를 빠르게 패키지로 만들어보고, 필요 없으면 과감히 버릴 수 있다.
모노레포에서는 이 과정이 부담이 적다. 독립 저장소를 만들 필요 없이, 같은 레포 안에서 시도하고 정리하면 되기 때문이다.

1. 협업과 유지보수의 단순화

프레임워크는 언젠가 나 혼자만의 프로젝트가 아닐 수 있다.
여러 사람이 참여했을 때, 모노레포 구조는 각자 맡은 패키지 단위로 책임을 나누게 해준다.
동시에 코드 리뷰나 테스트도 패키지 단위로 이뤄지니, 변화의 영향 범위를 좁혀 안정성을 높일 수 있다.

1. 문서화와 코드의 동행

문서는 별도 프로젝트로 분리하기보다, 모노레포 안에서 docs/ 같은 패키지로 관리하는 게 이상적이다.
API가 바뀌면 문서도 같은 맥락에서 수정할 수 있고, 예제 코드와 레퍼런스가 항상 최신 상태로 유지된다.
결국 문서와 코드가 같은 시간축 위에서 함께 진화하게 된다.

나는 지금 “아직 없는 것”을 준비하고 있다.
하지만 없는 것을 준비하는 방식이 곧 LynJS가 어떤 방향으로 자랄지를 결정한다.
모노레포는 그 방향을 열어두는 가장 안정적인 출발점이라 생각한다.

### 일관된 개발 환경 관리

프레임워크를 개발하다 보면 수많은 도구와 설정이 얽히게 된다.
타입스크립트 설정, 빌드 도구, 테스트 러너, 린터, 포매터…
이런 것들이 제각각 패키지마다 따로 관리된다면, 금세 혼란에 빠진다.

나는 지금 LynJS의 구상 단계에서 이 문제를 크게 의식하고 있다.
아직 구체적인 서브 프로젝트가 무엇일지는 모르지만, 확실한 건 여러 갈래로 나뉘는 순간이 반드시 온다는 사실이다.
그때 “이 패키지에는 ESLint가 이렇게 설정돼 있고, 저 패키지는 또 다르게 되어 있다” 같은 상황이 벌어지면, 개발자는 코드보다 환경 문제를 해결하느라 시간을 더 쓰게 된다.

모노레포는 이 문제를 선제적으로 막아준다.

- 공통 설정을 루트에서 정의하고 모든 패키지가 공유한다.
- 필요하면 특정 패키지에서만 최소한으로 덮어씌울 수 있다.
- 린터·포매터·타입 검사 등 기본 규칙이 일관되게 적용된다.

이렇게 되면 코드의 품질과 스타일은 어디서나 동일하게 유지된다.
나중에 새로운 패키지를 추가하더라도 별도의 설정을 처음부터 할 필요가 없다.
“코드 작성”이라는 본질에만 집중할 수 있도록 환경이 정돈되는 것이다.

프레임워크를 만드는 과정에서, 나는 기능 못지않게 이런 개발 경험(DX)의 기반을 중요하게 본다.
좋은 구조는 개발자에게 생각할 거리를 줄여주고, 에너지를 진짜 필요한 곳에 쏟을 수 있게 만든다.
일관된 개발 환경은 모노레포가 주는 가장 직접적이고 체감하기 쉬운 이점 중 하나다.

### 서브프로젝트 단위의 문제 해결

프레임워크를 개발하다 보면 문제가 생기지 않을 수 없다.
어떤 기능을 시도하다가 막힐 수도 있고, 새로운 아이디어를 실험하다가 실패할 수도 있다.
이때 중요한 건 문제를 어디서, 어떻게 다루느냐다.

단일 레포에서는 모든 코드가 한 덩어리로 얽혀 있다.
작은 기능을 바꾸려 해도 프로젝트 전체에 영향을 끼칠 수 있고, “여기서 고친 게 저기까지 파급되는 건 아닐까?” 하는 불안이 항상 따라온다.

반대로 모노레포는 문제를 더 작은 단위로 쪼개 다룰 수 있게 해준다.

새로운 시도를 할 때는 별도의 서브프로젝트로 만들어 실험할 수 있다.

특정 기능에서 오류가 발생하면, 그 패키지만 집중적으로 테스트하고 수정하면 된다.

다른 부분과 섞이지 않기 때문에 원인 파악과 검증이 더 명확해진다.

나는 지금 LynJS의 구상 단계에서, 앞으로 맞닥뜨릴 수많은 시행착오를 상상해본다.
그 과정이 두렵다기보다, 오히려 어떻게 시행착오를 효율적으로 다룰 수 있을까가 더 중요하다.
모노레포는 바로 그 해답 중 하나다.

“문제를 프레임워크 전체의 문제로 키우지 않고, 서브프로젝트 단위에서 끝낼 수 있다.”
이 점은 개발 속도뿐 아니라, 정신적인 안정감에도 큰 영향을 준다.

결국 나는 LynJS를 만들면서 문제를 피할 수는 없겠지만, 문제를 다루는 단위를 작게 가져감으로써 훨씬 건강한 리듬으로 개발을 이어갈 수 있으리라 생각한다.

### 공통 코드와 도구의 재사용

프레임워크를 만들다 보면 여러 부분에서 반복되는 코드와 설정이 생기기 마련이다.
빌드 스크립트, 타입 정의, 유틸리티 함수, 테스트 헬퍼, 개발용 설정 파일들…
단일 레포에서는 이런 것들을 매번 복사해 쓰거나, 한 군데에 억지로 몰아넣고 불러다 써야 한다.
결국 관리가 점점 복잡해지고, 수정할 때마다 여기저기 손을 대야 한다.

모노레포는 이 문제를 훨씬 단순하게 풀어준다.

공통 유틸리티를 별도의 패키지로 만들어 두면, 필요한 곳에서 의존성만 추가해 바로 쓸 수 있다.

빌드/테스트 스크립트 같은 도구들도 재사용 가능한 패키지로 관리하면, 중복 없이 유지보수할 수 있다.

설정이 바뀌어도 루트나 공용 패키지만 수정하면 모든 프로젝트에 적용된다.

나는 지금 LynJS의 구상 단계에서, 아직 어떤 기능이 생겨날지 명확히 알지 못한다.
하지만 하나는 확실하다. 겹치는 부분은 반드시 나온다.
그리고 그때마다 복붙으로 때우는 건 미래의 나를 괴롭히는 지름길이다.

모노레포는 이런 불필요한 반복을 줄이고, 한 번 만들어둔 코드를 여러 패키지에서 재사용할 수 있게 한다.
즉, **“한 번 만든 것은 어디서든 쓴다”**라는 원칙을 자연스럽게 실현할 수 있는 구조다.

프레임워크는 단순히 기능의 집합이 아니라, 유지보수가 가능한 체계여야 한다.
공통 코드를 효율적으로 관리하고 재사용할 수 있다는 점에서, 모노레포는 LynJS의 기반으로 매우 설득력 있다.

### 확장성과 유지보수성 확보

프레임워크는 한 번 만들고 끝나는 결과물이 아니다.
처음에는 작은 아이디어에서 출발하지만, 시간이 지나면서 기능이 늘어나고, 지원해야 하는 환경이 다양해지고, 새로운 요구가 계속해서 들어온다.
결국 중요한 건 얼마나 오래, 건강하게 유지될 수 있는가다.

나는 지금 LynJS를 구상하면서 이 부분을 특히 많이 고민한다.
처음에는 단일 레포로 시작하는 게 가벼워 보일 수 있다.
하지만 시간이 흐르면, “여기에 기능을 붙일 수 있을까?”, “저 부분을 분리해야 하지 않을까?” 같은 문제가 반드시 생긴다.
이때 단일 레포는 점점 무겁고 복잡해진다.

모노레포는 이런 변화에 대응하기 쉽다.

새로운 기능이 필요하다면, 기존 구조를 건드리지 않고 별도의 서브프로젝트로 확장할 수 있다.

문제가 생겨도 해당 패키지 안에서만 고치면 되니, 유지보수가 단순하다.

코드의 경계가 명확하니, 오래 지나도 어디를 손대야 하는지 금방 파악할 수 있다.

또 하나 중요한 점은 실험과 안정성의 균형이다.
프레임워크를 개발하다 보면 실험적인 기능을 추가하고, 또 과감히 버리는 일이 많아질 것이다.
모노레포는 이런 실험을 안전하게 격리할 수 있게 해주고, 이미 안정화된 부분은 그대로 유지할 수 있게 해준다.

나는 LynJS를 “처음 만들기 위한 구조”가 아니라, “앞으로 오랫동안 유지하고 발전시킬 구조”로 설계하고 싶다.
그런 관점에서 보면, 모노레포는 단순한 선택이 아니라 유지 가능성을 확보하는 전략이다.

## LynJS의 출발선

프레임워크를 만들겠다고 마음먹은 순간부터 나는 코드보다 구조를 먼저 고민했다.
기능은 언제든 덧붙일 수 있지만, 잘못 고른 구조는 되돌리기 어렵다.
그래서 이번 글에서는 LynJS가 어떤 토양 위에서 자라야 할지를 살펴봤다.

다음 글에서는 문서화의 중요성을 이야기할 예정이다.
프레임워크의 뼈대를 세우는 작업이 문서라면, 그다음은 실제 프로젝트를 열고 Astro를 설정하며 Git과 npm으로 환경을 꾸려나가는 과정이 될 것이다.

지금은 출발선에 불과하지만, 이렇게 하나씩 기록하며 걸어가면 LynJS는 점차 뚜렷한 모습으로 드러날 것이다.
