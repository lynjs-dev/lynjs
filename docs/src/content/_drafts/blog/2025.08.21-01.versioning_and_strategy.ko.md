# 버전 관리 — LynJS의 SemVer 운영 가이드

## 버전 정책의 중요성

작은 사이드 프로젝트에서는 `v1`, `v2`처럼 버전을 대충 올려도 큰 문제가 없다. 개인 프로젝트에서는 이해만 되면 충분하다.

하지만 프레임워크처럼 여러 개발자가 기여하고 외부 사용자가 사용하는 오픈소스의 경우 상황이 완전히 달라진다. 이때 버전은
단순한 숫자가 아니라 약속과 신뢰의 신호가 된다.

**사용자 입장에서는:**

- “이 업데이트는 단순한 버그 수정인가?”
- “새 기능이 추가되었는가?”
- “기존 코드가 깨질 수 있는 메이저 변경인가?”

버전 숫자만 보고 위험도를 판단할 수 있어야 한다.

**개발자 입장에서는:**

- 변경 이력을 체계적으로 관리할 수 있다.
- 팀 단위 협업에서 릴리스 시점을 조율하기 쉽다.
- CI/CD, 자동 배포 도구와 연계하여 안정적인 배포 흐름을 만든다.

**버전 관리 정책이 없을 경우 다음과 같은 문제 발생**

- 이전 버전에서는 잘 동작하던 코드가 갑자기 깨지는 이슈가 빈번히 발생한다.
- 패키지 업그레이드 시마다 코드를 일일이 확인해야 한다.
- 릴리스 과정이 즉흥적으로 진행되어 프로젝트 신뢰도가 떨어진다.

버전은 단순한 숫자가 아니라 **“현재 코드 상태를 안심하고 사용할 수 있는지”를 알려주는 최소한의 언어**이다. 따라서
LynJS는 처음부터 명확한 버전 정책을 세우는 것을 필수 조건으로 한다.

## Semantic Versioning(SemVer) 소개

프레임워크나 라이브러리는 시간이 지남에 따라 새 기능이 추가되고 버그가 수정되며, 때로는 호환성이 깨지는 큰 변화도
발생한다. 이때 개발자와 사용자가 같은 언어로 “이번 릴리스의 성격”을 이해할 수 있어야 한다.

이 역할을 하는 것이 Semantic Versioning, 줄여서 SemVer이다. 현재 거의 모든 오픈소스 프로젝트가 따르는 사실상의 표준 버전
체계이다.

### 규칙 설명

버전은 `MAJOR.MINOR.PATCH` 형식으로 표기한다.

- **MAJOR:** 기존과 호환되지 않는 변경 (Breaking change)
- **MINOR:** 호환성을 유지하면서 새로운 기능 추가
- **PATCH:** 버그 수정, 내부 개선

예시:

- `16 → 17`: 호환성 변경 포함
- `16.8 → 16.9`: 새 기능 추가 (마이너)
- `16.8.1 → 16.8.2`: 버그 수정 (패치)

### 과적용 사례

- 단순 리팩터링인데 `MAJOR`로 올리는 경우 → 불필요한 부담 발생
- 사소한 API 옵션 추가인데 `PATCH`로 올리는 경우 → 사용자 혼란 초래

  > 규칙은 엄격하게 적용하되, 과하지 않게 사용하는 것이 중요하다.

### LynJS가 적용하는 이유

- 오픈소스 생태계의 사실상 표준이다.
- 사용자에게 익숙하여 학습 비용이 없다.
- npm 의존성 해석이 SemVer를 기본 가정으로 하여 충돌을 방지한다.
- Changesets, semantic-release 등 자동화 도구와 잘 연계된다.

### 초기 0.x 버전 운영 방침

LynJS는 초기 버전을 0.x.x로 시작한다.

- 브레이킹 변경도 MINOR로 올린다 (`0.3.1 → 0.4.0`)
- 릴리스 노트 최상단에 **[BREAKING]** 배지로 강조한다.
- `1.0.0` 이후부터 엄격한 SemVer를 준수한다.

## SemVer 사용 방법

### MAJOR / MINOR / PATCH

- `feat`: 보통 minor 버전 증가
- `fix`: 보통 patch 버전 증가
- `perf`, `refactor`: patch (외부 API 불변 시)
- `docs`, `test`, `chore`: 버전 변경 없음

### 프리릴리스와 dist-tag

- `0.7.0-next.1` → 실험 또는 다음 버전 테스트용
- npm `dist-tag`를 활용하여 채널 관리

```bash
npm dist-tag add lynjs@0.7.0-next.1 next
npm dist-tag add lynjs@0.6.3 latest
```

### 릴리스 노트 작성 원칙

- 고정 섹션: `Added / Changed / Fixed / Deprecated / Removed / Security / Docs`
- Breaking change는 맨 위에 `[BREAKING]` 강조
- 가능한 한 **마이그레이션 코드 예시** 제공

## 모노레포에서의 버전 전략

### 독립 버전 관리 vs 일괄 버전 관리

- **일괄(Lerna fixed mode)**
  - 모든 패키지의 버전을 항상 동일하게 유지한다.
  - 장점: 단순하며 릴리스 동기화가 쉽다.
  - 단점: 변경이 없는 패키지도 같이 버전이 올라가 불필요한 bump가 많아진다.

- **독립(Independent mode)**
  - 각 패키지를 개별적으로 버전 관리한다.
  - 장점: 변경이 있는 패키지만 버전을 올려 유연성이 높다.
  - 단점: 패키지별 버전이 달라 관리 복잡도가 증가한다.

### LynJS의 선택

- 독립 버전 관리를 채택한다.
- `lynjs` 메타 패키지를 단일 진입점으로 노출한다.
- 내부 서브패키지는 모두 `"*"`로 참조한다.
- 릴리스 노트는 패키지별 상세 내용과 루트 요약본으로 구성한다.

### 호환성 매트릭스 정리

| 패키지        | 지원 lynjs 범위 | 비고                                       |
| ------------- | --------------- | ------------------------------------------ |
| @lynjs/dom    | `*` (내부)      | lynjs와 함께 설치 (0.7에 신규 DOM adapter) |
| @lynjs/env    | `*` (내부)      | 테스트 플래그 변경 예정 (Deprecated)       |
| 외부 플러그인 | `>=0.6 <1`      | peerDependencies로 lynjs 범위 명시         |

## 내부 패키지에서 의존성 버전 적용 방법

- 내부 패키지끼리는 항상 `"*"` 버전을 사용한다.
- 워크스페이스/Changesets가 배포 시 자동으로 현재 버전으로 치환한다.
- 장점:
  - 변경 시 불필요한 버전 bump 방지
  - 관리 단순화
  - 내부 구조 변경이 사용자 경험에 영향 없음

예시:

```jsonc
{
  "name": "lynjs",
  "version": "0.6.0",
  "dependencies": {
    "@lynjs/core": "*",
    "@lynjs/dom": "*",
    "@lynjs/reactive": "*",
  },
  "optionalDependencies": {
    "@lynjs/ssr": "*",
  },
}
```

## 외부 패키지에서 의존성 버전 적용 방법

### peerDependencies로 `lynjs` 명시

외부 플러그인은 내부 서브패키지(`@lynjs/core` 등)가 아니라, `lynjs` 자체를 peerDependencies로 의존해야 한다.

```jsonc
{
  "name": "@acme/lynjs-fancy-plugin",
  "peerDependencies": {
    "lynjs": ">=0.6 <1",
  },
}
```

### 플러그인 개발 가이드

- 항상 `lynjs` 공개 API만 사용한다.
- 내부 패키지에 직접 의존하지 않는다.
- peerDependencies를 통해 앱이 설치한 `lynjs`와 단일 인스턴스를 공유한다.
- 필요 시 `devDependencies`에 `lynjs`를 추가하여 개발 환경에서만 사용한다.

## 정리

- SemVer는 LynJS의 버전 정책 표준이다.
- 0.x.x 구간은 빠른 실험과 명확한 노트 작성 훈련 기간이다.
- 모노레포에서는 `"*"`와 Changesets로 관리 복잡도를 줄인다.
- 외부 플러그인은 항상 `lynjs`를 peer로 의존하여 단일 진입점을 공유한다.
