# JSX를 LynJS에 적용하기

LynElement의 `render` 함수 안에서 매번 `document.createElement`, `setAttribute` 같은 저수준 DOM API를 직접 호출해 UI를
만드는 것은 상당히 번거롭고 생산성을 떨어뜨릴 뿐만 아니라, 최종적으로 어떤 DOM 구조가 만들어지는지 한눈에 파악하기도
어렵게 만든다. 이러한 DOM 생성 방식은 결국 코드 가독성을 해치고, 시간이 지날수록 유지보수에도 큰 부담이 될 수 있다.

이 문제를 해결하기 위해 프론트엔드 개발에서는 **템플릿 언어**나 **선언적 UI 문법**을 도입해 왔으며, 다음 과 같은
대표적인 두 가지 흐름이 있따.

이 문제를 해결하기 위해 프론트엔드 개발에서는 **템플릿 언어**나 **선언적 UI 문법**을 도입해 왔으며, 대표적으로 다음 두
가지 흐름이 있다.

1. **HTML 템플릿을 그대로 작성하는 전통적인 방식**

- 직관적이고 배우기 쉽지만, 조건부 렌더링이나 반복 같은 동적 로직에는 한계가 있음

2. **자바스크립트 문법 안에서 UI를 표현하는 JSX 방식**

- 코드와 UI를 하나의 흐름 안에서 다룰 수 있어, 로직과 뷰 결합이 매끄러움

JSX는 겉보기에는 HTML과 비슷하지만 단순한 템플릿 언어는 아니다. JSX는 **조건문**, **반복문**, **변수 치환** 같은 로직을
그대로 표현할 수 있는 **자바스크립트의 확장 문법**이며, TypeScript와 결합하면 타입 안정성까지 확보되어 안전하고 직관적인
UI 선언이 가능하다. 자바스크립트 코드 안에서 HTML을 작성하듯, 코드와 UI를 긴밀하게 연결할 수 있다는 점이 JSX의 가장 큰
장점이다.

이런 특성 덕분에 JSX는 단순히 코드를 간결하게 만드는 편의 문법이 아니라, **선언적 UI를 구현하는 강력한 도구**가 된다.

LynJS가 지향하는 것도 바로 이러한 선언적 사용이다. 컴포넌트를 객체지향적으로 정의하면서도, 상태 변화가 곧바로 UI
갱신으로 이어지는 흐름을 직관적으로 드러내는 것이 목표이다. 여기에 JSX를 더하면 코드 구조와 UI 표현이 자연스럽게
맞물리며, LynJS가 추구하는 **선언적 구조 + 유연한 UI 선언**이라는 철학이 한층 더 강화된다.

LynJS에서 JSX는 단순한 편의 문법을 넘어, LynJS의 철학을 구체적으로 실현하는 핵심 도구이며 객체지향 리액티비티를 가장
자연스럽게 구현할 수 있는 표현 수단이다.

## JSX 도입 시 얻을 수 있는 이점

1. 생산성 향상

- DOM API 호출(createElement, setAttribute) 대신 직관적인 문법으로 UI 작성
- 코드량 감소와 함께 구현 속도 상승

2. 가독성과 유지보수성

- 최종적으로 만들어질 DOM 구조를 코드만 봐도 직관적으로 파악 가능
- 협업 시 코드 리뷰와 수정이 훨씬 수월해짐

3. 타입 안정성(TypeScript와 결합)

- 잘못된 속성이나 이벤트 바인딩을 IDE 단계에서 즉시 확인 가능
- 자동완성과 타입 추론 덕분에 개발 경험(DX)이 크게 개선

4. 선언적 패러다임과의 궁합

- 상태 변화가 곧 UI 갱신으로 이어지는 흐름을 표현하기 쉬움
- LynJS가 지향하는 객체지향 리액티비티와 자연스럽게 맞물림

## JSX 트랜스파일링 전략

JSX는 브라우저가 직접 해석하지 못하며 빌드 단계에서 트랜스파일러가 JSX를 일반적인 JavaScript(또는 DOM 근접 코드)로
변환해야 비로소 브라우저에서 실행된다. JSX 트래스파일러의 선택지는 크게 **Babel**, **SWC**, **esbuild**다.
트랜스파일러를 새로 만드는 일은 비용이 크니, 세 도구가 JSX를 어떻게 변환하는지 확인하고 LynJS 요구와 맞는지를 검토하는
게 순서다.

### Babel, SWC, esbuild의 기본 JSX 변환

**Babel**

- **기본 성향**: 플러그인 생태계가 넓고 변환 단계를 세밀하게 제어 가능
- **기본 출력(React preset 사용 시)** 입력:
  ```jsx
  <div className="greet">Hello {name}</div>
  ```
  출력 개념:
  ```js
  // @babel/preset-react
  React.createElement('div', { className: 'greet' }, 'Hello ', name);
  ```
- **확장성**: 커스텀 플러그인으로 **DOM 근접 변환**도 가능.

**SWC**

- **기본 성향**: 매우 빠른 컴파일. React 자동 런타임(jsx/jsxs) 경로에 최적화.
- **기본 출력(개념)**
  ```js
  import { jsx as _jsx } from 'react/jsx-runtime';
  _jsx('div', { className: 'greet', children: ['Hello ', name] });
  ```
- **확장성**: 커스텀 DOM 근접 변환 선택지가 제한적이며, 세밀한 변환 규칙 주입 난이도가 높음.

**esbuild**

- **기본 성향**: 번들/트랜스파일 속도 최상급. JSX는 주로 React 경로에 맞춰 변환.
- **기본 출력(개념)**
  ```js
  import { jsx as _jsx } from 'react/jsx-runtime';
  _jsx('div', { className: 'greet', children: ['Hello ', name] });
  ```
- **확장성**: JSX 변환 커스터마이즈 폭이 좁아 **DOM 근접 변환**으로의 치환이 쉽지 않음.

### 왜 LynJS에 바로 쓰기 어려운가

Babel, SWC, esbuild의 기본 JSX 변환은 공통적으로 **React Element** 같은 중간 표현(= Virtual DOM 용)을 만든다. 이 방식은
“가상 DOM과 실제 DOM을 비교(diff)해 바뀐 부분만 갱신하는 과정(리컨실리에이션)”에 최적화되어 있지만, **세밀한
업데이트(fine-grained)**에는 맞지 않는다.

문제 지점:

- **중간 표현 비용**: 한 번 더 추상화 계층을 거치면서 작은 변경에도 비교·패치 절차가 개입
- **업데이트 범위가 큼**: 특정 텍스트 노드만 바꾸면 되는 상황에서도 컴포넌트 단위 비교가 우선
- **이벤트 처리 단위**: 이벤트 위임·바인딩 전략을 미세하게 통제하기 어려움

LynJS가 원하는 것은 중간 표현 없이, **바로 DOM에 가까운 호출로 내려가는 변환**이다. 아래는 LynJS가 지향하는 “DOM 근접
호출”의 흐름 예시다.

입력:

```tsx
// state는 LynJS의 세밀 반응(예: signal, getter)이라고 가정
<button class="greet" onClick={onClick}>
  Hello {name()}
</button>
```

출력:

```ts
// 1) 정적 템플릿은 캐시해 복제 비용 최소화
const _tmpl$ = template(`<button class="greet">Hello </button>`, 2);
// 2) 노드 생성
const el = _tmpl$.cloneNode(true);
// 3) 동적 영역만 삽입 -> name() 변경 시 해당 지점만 업데이트
insert(el, name);
// 4) 이벤트는 위임 방식으로 연결(필요 시 한 번만 설정)
delegateEvents(['click']);
// 혹은 직접 바인딩: el.addEventListener("click", onClick)
el.__click = onClick;
// 이제 el은 곧바로 DOM에 붙이면 끝.
// parent.appendChild(el)
```

핵심은 **Virtual DOM을 거치지 않고 텍스트·속성·이벤트 같은 변경 지점을 정밀하게 갱신**한다는 점이다.

이러한 정밀한 갱신 방식은 SolidJS에서도 동일하게 적용되고 있으며, 이를 위해 SolidJS는
**babel-plugin-jsx-dom-expressions**를 사용한다. 이 플러그인은 JSX를 DOM 근접 코드로 변환하고, 함께 제공되는
**dom-expressions** 런타임을 통해 템플릿 캐싱, 동적 값 삽입, 이벤트 위임 등을 처리한다.

LynJS 역시 이 접근을 채택함으로써, 트랜스파일러를 직접 개발하지 않고도 **fine-grained 업데이트 모델**을 안정적으로
구현할 수 있을 것이다.

## Babel preset 제공

**babel-plugin-jsx-dom-expressions**를 사용하려면 사용자가 프로젝트에 Babel 플러그인 설정을 직접 추가해야 하는데, 이
과정을 매번 반복하다 보면 번거롭고 작은 설정 실수만으로도 빌드가 실패할 수 있다. 만약 이런 설정 부담을 그대로 사용자에게
떠넘긴다면 단순히 설정의 어려움 때문에도 LynJS 사용을 꺼리게 될 것이다.

이 문제를 해결하기 위해 LynJS는 **babel-preset-lynjs**를 제공한다. 이 프리셋에는 JSX 변환을 위한
**babel-plugin-jsx-dom-expressions**뿐 아니라 LynJS 구동에 필요한 전용 규칙도 함께 포함된다. 따라서 개발자는 복잡한
Babel 설정을 직접 다룰 필요 없이 프리셋 하나만 추가하면 되고, 곧바로 JSX 지원과 LynJS 사용에 필요한 기본 설정이 자동으로
활성화되어 별다른 추가 작업 없이 바로 활용할 수 있다.

**babel-preset-lynjs**를 사용하면 필요한 다른 Babel 플러그인들도 함께 적용되므로 설치 직후부터 **일관되고 안정적인 개발
환경**을 그대로 확보할 수 있다.

## babel-preset-lynjs 패키지 생성

babel-preset-lynjs는 LynJS를 위한 전용 Babel 프리셋이다. 현재는 babel-plugin-jsx-dom-expressions 적용을 위한 설정만
제공하고 있지만, 향후에는 LynJS 사용 과정에서 필요한 다른 Babel 플러그인이나 기본 설정도 이 프리셋을 통해 통합적으로
관리할 예정이다. 따라서 사용자는 복잡한 Babel 설정을 직접 추가할 필요 없이, babel-preset-lynjs만 적용하면 LynJS 실행에
필요한 환경을 곧바로 갖출 수 있다.

## 디렉토리 구성

```text

lynjs/
├─ packages/
│  └─ babel-preset-lynjs/
│     ├─ package.json
│     ├─ index.cjs
│     ├─ README.md
│     └─ LICENSE              # BSD-3-Clause

```

**packages/babel-preset-lynjs/package.json**

```json
{
  "name": "babel-preset-lynjs",
  "version": "0.1.0",
  "description": "Babel preset to transform JSX for Lyn.JS",
  "main": "index.cjs",
  "author": "MoGi <mogiblahblah@gmail.com>",
  "license": "BSD-3-Clause",
  "keywords": ["babel-preset", "lynjs", "jsx", "typescript", "babel"],
  "files": ["index.cjs"],
  "dependencies": {
    "babel-plugin-jsx-dom-expressions": "^0.40.1"
  },
  "devDependencies": {
    "@babel/core": "^7.28.4",
    "@babel/preset-env": "^7.28.3",
    "@babel/preset-typescript": "^7.27.1"
  },
  "peerDependencies": {
    "@babel/core": "^7.28.4",
    "@babel/preset-env": "^7.28.3",
    "@babel/preset-typescript": "^7.27.1",
    "lynjs": "^0.1.0-next.1",
    "typescript": "^5.9.3"
  },
  "peerDependenciesMeta": {
    "lynjs": {
      "optional": true
    }
  }
}
```

**package/babel-preset-lynjs/index.cjs**

```js
const jsxTransform = require('babel-plugin-jsx-dom-expressions');

module.exports = function (context) {
  return {
    presets: [
      [
        '@babel/preset-env',
        {
          debug: false,
          modules: false,
          targets: {
            chrome: 58,
            safari: 12,
            firefox: 58,
          },
        },
      ],
      ['@babel/preset-typescript', { allowDeclareFields: true }],
    ],

    plugins: [
      // 플러그인 순서 유지
      ['@babel/plugin-transform-typescript', { allowDeclareFields: true }],
      [
        jsxTransform,
        {
          moduleName: '@lynjs/dom',
          contextToCustomElements: true,
          wrapConditionals: true,
          generate: 'dom',
          ...options,
        },
      ],
    ],
  };
};
```

**LynJS 시작 하기**

```bash
npm i -D @babel/core @babel/preset-env @babel/preset-typescript typescript babel-preset-lynjs
```

개발 의존선 패키지 설치

    "@babel/preset-typescript"
    "babel-plugin-jsx-dom-expressions"

peer
