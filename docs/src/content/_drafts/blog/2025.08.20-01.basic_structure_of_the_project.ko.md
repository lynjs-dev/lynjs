# 프로젝트 구조

새로운 프레임워크를 만들 때 가장 먼저 떠오르는 질문은 “어디서부터 시작할까?”이다. 이 문서는 기능 구현에 앞서
**프로젝트의 도화지** —구조, 도구, 문서화—를 어떻게 정하고 왜 그렇게 하는지 정리한다.

아직 LynJS는 구현 전 단계다. 지금 필요한 것은 코드가 아니라, 이후의 모든 작업을 안정적으로 담아낼 토대다. 잘못 고른
토대는 되돌리기 어렵고, 나중에 큰 비용을 초래한다. 따라서 **구조·도구·문서화**를 우선 결정한다.

## 왜 프로젝트 구조가 중요한가?

프레임워크 개발은 단순히 기능을 쌓는 일이 아니다. 시간이 지날수록 기능은 늘어나고, 다양한 환경에서 테스트되며, 외부
기여가 유입된다. 이때 가장 먼저 부딪히는 문제가 바로 **프로젝트 구조**다.

프로젝트 구조는 폴더 배치 이상의 의미를 갖는다. 다음을 좌우하는 **뼈대**다.

- 새 기능을 어디에 추가할지
- 공통 로직을 어떻게 재사용할지
- 문서와 테스트를 어떤 흐름으로 관리할지
- 신규 기여자가 얼마나 빨리 이해하고 참여할 수 있을지

처음의 선택이 잘못되면, 빌드 체인과 배포 파이프라인까지 **전면 재설계**해야 하는 상황을 부른다. 그래서 코드를 쓰기 전에
구조를 먼저 고도화해야 한다.

## 단일 레포 vs 모노레포 비교

**단일 레포(single repo)**

- 전체가 하나의 패키지로 묶여 설정이 단순하다.
- 작은 라이브러리나 도구에 적합하다.
- 규모가 커지면 공통/실험 코드가 뒤섞여 추적이 어려워진다.

**모노레포(monorepo)**

- 워크스페이스, 공용 빌드/테스트 환경을 먼저 세팅해야 해 출발선이 무겁다.
- 초기 비용은 있지만, 기능 분화·실험 격리·공통 도구 공유에 유리하다.
- 패키지별 배포·버전 전략을 유연하게 적용할 수 있다.

**요약**

- 단일 레포: 지금 당장 빠른 시작에 유리.
- 모노레포: 무엇이 생겨날지 모르는 상황에서의 **확장성** 보장.

## 모노레포를 선택한 이유 (선택 근거)

- **미지의 확장을 위한 여백**: 초기에는 패키지 경계를 느슨하게 가정하고, 개발 진행에 따라 자연스럽게 분화한다.
- **결합은 느슨하게, 경계는 선명하게**: 내부 계약(인터페이스)과 의존 그래프를 일찍부터 건강하게 관리한다.
- **공통 도구의 단일화**: 린터/포매터/테스트/타입 설정/커밋 규칙을 루트에서 일괄 관리한다.
- **실험과 폐기의 비용 최소화**: 실험용 패키지를 붙였다 떼기가 쉽다.
- **릴리스 전략의 유연성**: 단일 버전 → 독립 버전, 부분 배포 등으로 자연스럽게 전환 가능.
- **문서화와 개발의 동거**: `docs/`를 동일 저장소에서 운영해 변경을 하나의 PR에서 동기화한다.

## 모노레포가 주는 이점

1. **확장의 여지:**
   - 어떤 서브프로젝트가 생겨날지 모르는 단계에서, 모노레포는 분화를 전제한 구조를 제공한다. 필요할 때 별도 패키지로
     손쉽게 떼어 관리한다.
2. **공통 도구의 일관성:**
   - 공통 설정을 루트에서 정의하고 전 패키지가 공유
   - 특정 패키지에서만 필요한 최소 오버라이드 허용
   - 코드 품질/스타일/타입 규칙의 일관성 보장
3. 실험과 폐기의 유연성
   - 아이디어를 빠르게 패키지로 만들어 검증하고, 불필요하면 안전하게 제거한다. 독립 저장소 생성·정리 비용이 없다.
4. 협업과 유지보수의 단순화
   - 패키지 단위로 책임을 분리해 리뷰·테스트 범위를 좁히고 영향 분석을 명확히 한다.
5. 문서화와 코드의 동행
   - 문서는 별도 리포지토리보다 같은 레포의 `docs/`로 관리하는 편이 바람직하다. API 변경과 문서 변경을 동일 타임라인에서
     다룬다.
6. 일관된 개발 환경 관리
   - 패키지마다 도구와 설정이 달라지면 개발자는 코드 작성보다 환경 문제 해결에 더 많은 시간을 쓰게 된다. 모노레포는 이를
     방지하기 위해 루트에 공통 설정을 두고 전체 패키지에서 공유한다. 필요한 경우에만 최소한으로 패키지별 재정의를
     허용하며, 린트, 포맷, 타입 검사, 테스트까지 표준화된 환경을 제공한다.

## 서브프로젝트 단위의 문제 해결

문제는 작은 단위에서 격리해 다루는 편이 원인 파악과 검증에 유리하다. 모노레포에서는 다음이 가능하다.

- 새로운 시도를 별도 패키지에서 실험
- 오류가 발생한 패키지만 집중 테스트·수정
- 파급 범위를 최소화한 검증 루프

## 공통 코드와 도구의 재사용

반복되는 유틸리티·타입 정의·빌드/테스트 스크립트를 **공용 패키지**로 만들어 재사용한다. 한 번 만든 것은 어디서든 쓴다.

## 확장성과 유지보수성 확보

프레임워크는 장기 진화가 전제된다. 모노레포는 다음을 용이하게 한다.

- 새로운 기능을 별도 패키지로 확장
- 문제가 생긴 지점을 해당 패키지에서만 수정
- 경계가 명확해 장기간에도 위치 파악이 신속
- 실험과 안정 영역을 안전하게 분리

## LynJS의 출발선

구조는 방향을 만든다. LynJS는 **기능보다 구조**를 먼저 다져, 이후의 확장·실험·문서화를 한 공간에서 일관되게 운영한다.
다음 단계에서는 문서화를 실제로 연결하기 위해 Astro 기반의 사이트를 열고, Git과 npm으로 배포 파이프라인의 최소 골격을
마련한다.

출발선은 단순하지만, 올바른 구조 위에서 걸어가는 한 걸음이 이후의 비용을 근본적으로 줄인다.
