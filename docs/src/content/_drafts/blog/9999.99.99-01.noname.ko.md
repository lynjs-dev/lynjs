## 지금의 질문들, 그리고 기록의 방식

프로젝트를 막 시작했을 때 가장 먼저 풀어야 할 질문들이 있다. 각각은 독립적인 글과 문서 섹션으로 확장될 예정이다.

1. **JSX는 어떻게 트랜스파일링할까?** React, Solid, Svelte가 각기 다른 방식으로 접근하는 만큼, LynJS만의 규칙과 빌드
   경로를 정의해야 한다. Babel 기반으로 갈지, SWC/Esbuild를 쓸지, 변환 결과를 어떤 DOM API와 맞출지부터 설계한다.

2. **객체지향에 맞는 fine‑grained reactivity** 함수형 패러다임에 치우친 기존 접근과 달리, 클래스와 객체의 **생명주기**에
   자연스럽게 녹아드는 반응성 모델이 필요하다. 데코레이터(@attr, @state 등), 의존성 추적, 업데이트 스케줄링, host/impl
   분리 같은 키워드를 중심으로 구체화한다.

3. **HMR(Hot Module Replacement)과 SSR(Server‑Side Rendering)** 단순히 "돌아간다"를 넘어서, **개발자가 쓰기 편한
   HMR/SSR** 경험을 설계한다. 상태 보존(예: State‑Preserving Host Pattern), 호스트/구현체 스왑, 아일랜드/하이드레이션
   전략을 함께 고민한다.

4. **개발 환경과 도구 선택** Webpack의 안정성과 Vite의 민첩성 중 어디에 앉을지, 혹은 둘을 병용할지 결정한다. 번들링은
   최소화하되, 테스트/예제/문서 사이트에서는 합리적인 편의성을 허용하는 기준을 문서로 확정한다.

5. **진입 경험(DX) 설계** `npx create-lynjs-app` 같은 **간단한 온보딩 경로**를 목표로 한다. 템플릿/프리셋/실행
   스크립트를 어떤 패키지로 분리할지, 인터랙티브 프롬프트 제공 여부까지 논의한다.

6. **모노레포 & 테스트 전략** 여러 패키지가 맞물려 돌아가는 구조에서 버저닝, 브랜칭, CI, 테스트 실행 순서를 어떻게
   표준화할지 고민한다. 유닛/통합/예제 스냅샷 테스트를 어떤 단계로 배치할지 정의한다.

7. **문서화 전략** API 레퍼런스만으론 부족하다. 튜토리얼, 가이드, 예제, 디자인 원칙을 한데 묶어 **“왜 LynJS인가”**를
   전달한다. 도구로는 **Astro**를 선택해 블로그/문서/예제 플레이그라운드를 한곳에서 운영한다.

8. **배포 전략** ESM/CJS 이원화, 브라우저/Node 타깃, 번들/비번들 배포 경계, 타입 배포 정책을 명문화한다. 사용자의
   선택권과 기본값의 균형을 맞춘다.

9. **알림과 확산(DevRel)** 블로그, 문서, 예제 코드, X/Twitter, Hacker News 등 다양한 채널로 소식을 전한다. "무엇을,
   언제, 어디에" 게시할지 운영 룰로 고정한다.

각 주제는 “문제 정의 → 설계 옵션 비교 → 결정(또는 가설) → 근거 → 다음 액션” 형식으로 기록한다. 결정은 **ADR(Architecture
Decision Record)** 로, 실험은 **실험 노트/실행 로그**로 남긴다.

---

## 문서 도구: 왜 Astro로 시작하는가

문서는 단순 레퍼런스가 아니라, 블로그와 튜토리얼, 라이브 예제를 한데 묶은 **다층적 사이트**여야 한다. Astro는 프레임워크
중립적이라 React/Vue/Svelte 등 다양한 컴포넌트를 혼합할 수 있고, 정적 사이트 생성(SSG) 성능도 뛰어나다. 무엇보다 **LynJS
컴포넌트를 문서 안에서 직접 시연**하기 딱 좋다.

- **장점**
  - 프레임워크 중립: 다양한 UI 라이브러리를 혼합 가능 → LynJS 웹 컴포넌트 시연에 딱!
  - 빠른 SSG 빌드와 유연한 라우팅: 블로그/가이드/예제 갤러리 동시 운영 OK
  - 마케팅/문서/실험 공간을 하나로 통합하기 쉬움
- **보완점**
  - 버전 관리/내장 검색 등은 플러그인이나 외부 서비스로 보강한다 (예: Algolia DocSearch, 자체 버전 디렉터리 전략).

> 결론: **Astro로 시작**하되, 필요하면 문서 버전 관리를 보강하고, 컴포넌트 데모 영역은 독립 패키지로 분리해 재사용성을
> 높인다. 👉 나중에 확장하기 편하다!

---

## 모노레포와 문서의 나란한 진화

문서는 별도 저장소로 분리하지 않고 **모노레포의 `docs/` 패키지**에서 관리한다. 이렇게 하면 코드 변경과 문서 변경을
**같은 PR**에서 다룰 수 있어, 실제 동작과 문서 간 괴리를 줄일 수 있다.

- **원칙**
  - 기능 변경 PR에는 관련 문서 변경을 **반드시 포함**한다.
  - 문서도 테스트한다: 코드 스니펫 실행 검증, 예제 스냅샷, 링크 체크를 CI에 포함한다.
  - 릴리즈 노트와 문서 변경 이력을 자동 생성한다(Conventional Commits 기반).

- **폴더 구조 초안**
  ```
  lynjs/
    packages/
      ...
    docs/               # Astro 기반 문서/블로그
      content/
        blog/
        guides/
        api/
        concepts/
        cookbook/
        adr/            # Architecture Decision Records
        rfc/            # 큰 변화 제안 기록
      playground/       # 라이브 예제(별도 패키지로도 분리 가능)
      integrations/     # Astro와 LynJS 통합 헬퍼(필요 시)
  ```

---

## 문서의 톤 & 포맷 가이드(초안)

- **톤:** 솔직하고 투명하게. 현재 상태(가설/제한/미결)를 숨기지 않는다.
- **포맷:** 각 글은 “배경 → 문제 정의 → 대안 비교 → 결정/가설 → 구현 스케치 → 검증/측정 → 다음 액션”을 기본 뼈대로 한다.
- **코드 스니펫:** 실행 가능하거나, 최소한 타입 체커를 통과하는 예제를 지향한다.
- **그림/도표:** 복잡한 데이터/흐름은 다이어그램으로 병기한다.
- **상태 배지:** `status: draft | proposed | accepted | replaced | deprecated` 를 머리말에 명시한다.

---

## 작성/리뷰/릴리즈 흐름(초안)

1. 이슈로 **문제 정의**를 등록한다 (레이블: `docs`, `design`, `rfc` 등).
2. 브랜치에서 실험/프로토타입과 함께 **문서 초안**을 작성한다.
3. PR을 열어 코드와 문서를 **동시에 리뷰**받는다.
4. 머지 시 CI가 문서 사이트를 빌드하고 프리뷰를 생성한다.
5. 릴리즈 커밋에 맞춰 **변경 로그와 문서 링크**를 함께 배포한다.

---

## 시작을 돕는 문서 목차(초안)

- **Getting Started**
  - LynJS 소개: 철학과 목표
  - 빠른 시작: 템플릿으로 5분 설치
  - 첫 컴포넌트 만들기(Hello, Host!)
- **Concepts**
  - Host / Implementation 분리
  - 데코레이터와 메타데이터(@attr, @state …)
  - Fine‑grained Reactivity와 스케줄러
  - State‑Preserving Host Pattern(SPHP) 개요
- **Guides**
  - HMR에서 상태 보존하기
  - SSR/아일랜드 하이드레이션 전략
  - 테스트와 모킹, 예제 스냅샷
  - 모노레포 버전/브랜치 운영
- **API**
  - 패키지별 API 레퍼런스(@lynjs/core, @lynjs/dom …)
- **Cookbook**
  - 입력 폼/유효성/접근성 패턴
  - 데이터 그리드 미니 예제
  - Astro/Next/Astro‑Island 통합 예제
- **ADR / RFC**
  - 결정 기록과 근거 모음

---

## 실행 체크리스트(첫 주)

- [ ] `docs/`에 Astro 초기화, 기본 레이아웃/검색/다국어 토대 마련
- [ ] 문서 목차 골격 생성 및 라우팅 연결
- [ ] “문서화 원칙” 문서 공개 (이 글)
- [ ] 첫 ADR: "문서 도구로 Astro를 채택" 등록
- [ ] 블로그 1편: "프로젝트 생성 → GitHub → npm 첫 배포"(이미 작성한 포스팅과 연동)

---

## 에필로그 — 코딩은 곧 시작이지만, 기록이 먼저다

기능을 서둘러 완성하기보다 **문제를 정확히 정의하고, 가설을 세우고, 실험과 결정을 기록**하는 게 더 중요하다. 이 기록들이
쌓이면 LynJS는 단순 기능 목록을 넘어 **일관된 철학과 경험**을 가진 도구로 성장한다.

프레임워크는 코드만으로 존재하지 않는다. 사용자가 이해하고 따라올 수 있는 **길**이 있을 때 비로소 살아 움직인다. 그 길을
지금부터 차근차근, 문서로 깔아보자.
