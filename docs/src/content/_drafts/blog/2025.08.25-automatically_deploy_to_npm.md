# NPM 자동 배포하기

프로젝트를 하다 보면 `npm version patch && npm publish` 명령어를 직접 실행해서 배포하곤 한다. 처음에는 간단하다.
하지만 협업이 늘어나고 릴리스 주기가 짧아지면 이 과정에서 실수가 잦아진다.

- 누가 언제 어떤 버전으로 배포했는지 기록이 흐릿하다.
- 로컬 환경마다 설정이 달라서 배포에 실패하거나, 의도치 않게 다른 파일이 포함된다.
- 깜빡하고 테스트를 건너뛴 채 배포하면, 사용자에게 깨진 버전이 노출된다.

이런 문제를 막으려면 **GitHub Actions 같은 CI 파이프라인에서 자동으로 npm에 배포**되도록 하는 게 가장 확실하다.

자동화하면 얻는 장점은 명확하다.

- 태그를 푸시하는 것만으로 배포 완료
- 테스트가 통과하지 않으면 아예 배포가 막힘
- 프리릴리스(`next`)와 정식(`latest`) 채널을 분리해 안정적인 흐름 보장

자동 배포를 통해 사람 손을 거치지 않고도 **안정적이고 투명한 배포 사이클**을 유지할 수 있다.

## 목표

이번 설정의 목표는 “사람 손을 최소화하면서도 안전하게” npm 배포가 돌아가게 만드는 것이다. **태그 한 번 푸시 → 테스트 통과 → 버전/릴리스/배포까지 자동**을 최종 상태로 둔다.

### 할일

- **태그 기반 원클릭 배포**
  - `vX.Y.Z` 태그 푸시 → `latest` 채널 자동 배포
  - `vX.Y.Z-next.N` 태그 푸시 → `next` 채널 자동 배포
- **CI 필수 게이트**
  - 테스트/빌드 실패 시 **배포 차단**
  - 커밋 메시지는 **Conventional Commits**로 강제(commitlint)
- **투명한 릴리스 로그**
  - `CHANGELOG.md` 자동 갱신
  - GitHub Release 자동 생성(아티팩트 첨부 가능)
- **배포 파일 컨트롤**
  - `npm pack --dry-run`으로 포함 파일 사전 검증
  - `files` 또는 `.npmignore`로 최소 포함만 유지
- **프리릴리스 운영 루틴 확보**
  - 기능은 `next` 채널로 조기 배포/검증 → 안정화 후 `latest` 승격
- **모노레포 확장 여지**
  - 현재는 루트 패키지 1개 기준
  - 향후 패키지 증가 시 **Changesets/semantic-release**로 자연 확장 가능

### 성공 기준

- [ ] `main`/`next`에 머지되거나 `v*` 태그를 푸시하면 **사람 개입 없이** npm 배포가 완료된다.
- [ ] 실패하는 테스트가 있으면 **배포가 중단**된다.
- [ ] `npm view <pkg> dist-tags`에서 `latest`/`next`가 의도대로 갱신된다.
- [ ] GitHub Releases에 해당 버전이 생성되고, `CHANGELOG.md`가 업데이트된다.
- [ ] `npm pack --dry-run` 결과가 **의도한 파일만** 포함한다.
- [ ] 로컬 PC에 토큰을 저장/커밋하지 않아도 **배포가 가능**하다.

### 범위

- **포함**: GitHub Actions 워크플로우, semantic-release(또는 태그 트리거 워크플로우), commitlint+husky, `CHANGELOG.md` 자동화, `files/.npmignore` 정비.
- **제외(이번 글)**: 다중 패키지 동시 배포(Changesets 상세 구성), 애플리케이션 번들링/빌드 최적화, 배포 후 문서 사이트 자동 배포(후속 글에서 연동).

### 빠른 사용 예

```bash
# 프리릴리스(next 채널)
npm run release:next
# -> v0.1.0-next.0 태그 생성 & 푸시
# -> CI가 next로 배포

# 정식 릴리스(latest 채널)
npm run release:patch   # 또는 :minor / :major
# -> v0.1.0 태그 생성 & 푸시
# -> CI가 latest로 배포
```

> 요약: **커밋을 규칙대로 쓰고(PR 머지 or 태그 푸시) → CI가 나머지를 전부 처리**한다. 릴리스는 기록 가능하고, 재현 가능하며, 안전해야 한다.

## 왜 자동 배포가 필요한가?

- **휴먼 에러 감소:** 로컬에서 버전 올리고 `npm publish` 치고… 이런 수작업은 한번쯤 실수합니다. CI에 태그/머지 이벤트만 던지면 끝이 되게 하자.
- **일관된 릴리스 프로세스:** 테스트 통과 + 빌드 성공 + 버전/체인지로그 생성 → 배포까지 한 파이프로 보장.
- **권한/보안 분리:** 개인 PC 토큰 없이, GitHub의 시크릿과 npm **Automation Token**으로 안전하게 배포.

## 자동 배포 방법에는 무엇이 있나?

자동 배포에도 몇 가지 접근 방식이 있다. 상황에 맞는 걸 고르면 된다.

### A안) 단일 패키지(또는 루트 패키지) 자동 배포

- 태그(`v0.1.0` 같은 것)를 푸시하면 CI가 감지해서 배포한다.
- `v0.1.0-next.0` 같은 프리릴리스 태그는 `next` 채널, `v0.1.0` 같은 정식 태그는 `latest` 채널로 구분된다.
- 지금 LynJS처럼 **루트 패키지 하나만 배포**하는 경우에 딱 맞다.
- 설정이 단순하고 러닝커브가 거의 없다.

### B안) 모노레포(여러 패키지) 자동 배포

- `packages/*` 안의 여러 패키지를 각각 버전 관리/배포해야 한다면 **Changesets** 같은 도구를 쓴다.
- PR마다 변경 내용을 기록하고, 태그가 찍히면 변경된 패키지들만 자동 배포된다.
- 대규모 모노레포에서 많이 쓰이는 방식이다.
- 단일 패키지만 배포할 땐 오버엔지니어링이다.

### C안) semantic-release

- 커밋 메시지를 분석해서 버전 증가, 릴리스 노트 작성, GitHub Release, npm 배포까지 전부 자동화한다.
- 팀 전체가 **Conventional Commits**를 잘 지킬 때 위력이 크다.
- 완전 자동화에 가깝지만, 설정 난이도가 있다.

## 왜 semantic-release 인가?

앞서 살펴본 A안(단일 패키지 자동 배포)과 B안(모노레포 자동 배포)은 상황에 따라 충분히 좋은 선택이 된다.
하지만 LynJS는 단순히 버전을 올려서 배포하는 것 이상을 목표로 한다.

### C안을 선택한 이유

- **버전 증가를 자동화하고 싶다**
  사람이 `npm version patch` 같은 명령을 직접 치는 순간부터 휴먼 에러가 끼어들 수 있다. semantic-release는 커밋 메시지를 기준으로 버전을 계산하므로, 릴리스 과정에서 사람이 개입할 여지가 줄어든다.

- **CHANGELOG와 릴리스 노트를 자동으로 관리하고 싶다**
  기능 추가나 버그 수정이 쌓일수록 “이번 버전에 뭐가 바뀌었지?”를 따로 정리하는 일이 번거롭다. semantic-release는 Conventional Commits를 기반으로 `CHANGELOG.md`와 GitHub Release 노트를 자동으로 만들어준다.

- **채널 분리를 손쉽게 하고 싶다**
  `main` 브랜치 → `latest` 채널, `next` 브랜치 → `next` 채널로 자동 배포된다. 프리릴리스와 정식 릴리스를 자연스럽게 구분할 수 있다.

- **장기적인 확장성 확보**
  지금은 루트 패키지 하나만 배포하지만, 모노레포 구조에서 패키지가 늘어나더라도 semantic-release는 그대로 활용할 수 있다. 플러그인 구성을 조금만 바꾸면 된다.

정리하면, C안은 **“커밋만 잘 쓰면 나머지는 다 자동”**이라는 점이 가장 큰 매력이다.
프레임워크 레벨의 프로젝트에서는 이 자동화가 개발 속도와 안정성 모두에 큰 도움이 된다.

### semantic-release가 하는 일

배포에서 사람이 직접 하던 일(버전 올리기, 태그 달기, 릴리스 노트 쓰기, npm publish)을 **커밋 메시지 규칙**에 따라 완전 자동으로 처리한다.

- **커밋 → 버전 자동 결정**
  - `fix:` → PATCH
  - `feat:` → MINOR
  - `feat!:` 또는 본문에 `BREAKING CHANGE:` → MAJOR

- **한 번 머지로 끝**
  `main`이나 `next` 브랜치에 머지되면 CI가 알아서: 버전 계산 → CHANGELOG 생성 → GitHub Release → npm 배포까지 진행한다.

- **채널 분리 자동화**
  - `main` 브랜치 → `latest`
  - `next` 브랜치 → `next`(프리릴리스)

> 비유하자면, semantic-release는 “릴리스 매니저 봇”이다.
> 개발자가 지켜야 할 건 단 하나, **커밋을 Conventional Commits 규칙에 맞게 작성하는 것**뿐이다.

## semantic-release 설정

> 전제: 지금은 **루트 패키지 `lynjs` 하나만 배포**한다. (모노레포지만 단일 패키지 배포 구성)

### 필수 토큰 준비

semantic-release가 제대로 동작하려면 두 가지 토큰이 필요하다.

- npm에 배포하기 위한 **npm Granular Access Token**
- GitHub Release, 태그 푸시 등에 필요한 **GITHUB_TOKEN**

**npm Granular Access Token**

- `@semantic-release/npm` 플러그인이 npm 레지스트리에 패키지를 배포 할 때 인증용으로 사용된다.
- 발급 방법
  1. [npmjs.com → 계정 Settings → Access Tokens](https://www.npmjs.com/settings)
  2. **“Generate New Token”** 클릭
  3. **Granular Access Token** 타입 선택
  4. 생성된 토큰 문자열을 복사한다.
  5. GitHub 저장소 → **Settings → Secrets and variables → Actions → New repository secret**
  - 이름: `NPM_TOKEN`
  - 값: 발급받은 토큰 문자열

> ⚠️ 토큰은 **한 번만 확인 가능**하니 꼭 안전한 곳에 저장해 두자.
> 유출되면 누구나 배포할 수 있으니, 문제가 생기면 npm에서 바로 revoke해야 한다.

**GITHUB_TOKEN**

- GitHub Actions 워크플로우 실행 시 **자동으로 발급되는 단기 토큰**이다.
- `@semantic-release/github`, `@semantic-release/git` 플러그인에서 사용된다.
  - GitHub Release 생성
  - 태그 푸시
  - `CHANGELOG.md`/`package.json` 같은 파일을 릴리스 커밋으로 푸시

- 발급 방법
  - 별도로 발급할 필요가 없다.
  - GitHub Actions에서 기본으로 제공되는 환경 변수 `${{ secrets.GITHUB_TOKEN }}`을 그대로 사용하면 된다.

**권한 설정**

- semantic-release가 릴리스/태그/커밋 작업을 하려면 **write 권한**이 필요하다.
- 워크플로우 파일 상단에 다음을 추가해둔다.

```yaml
permissions:
  contents: write # 릴리스, 태그, 커밋
  issues: write # (옵션) 릴리스 결과 코멘트
  pull-requests: write # (옵션) PR에 코멘트 남길 때
```

- 저장소 Settings → Actions → General → Workflow permissions → **Read and write permissions** 활성화도 확인한다.

### 작업 브랜치 생성

자동 배포에서는 `main`을 **안정(stable, `latest`) 채널**, `next`를 **프리릴리스(pre-release, `next`) 채널**로 사용한다.
즉, 새로운 기능이나 실험적인 변경은 `next`에서 먼저 배포해보고, 충분히 검증된 시점에 `main`으로 병합해 안정판으로 승격한다.

먼저 `v0.0.1` 태그를 기준으로 `next` 브랜치를 만든다.
그다음 실제 작업은 별도의 기능 브랜치(`feature/ci-npm-setup`)에서 진행하고, 검증 후 `next`에 병합하는 흐름으로 운영한다.

```bash
# v0.0.1 태그에서 next 브랜치 생성
git checkout -b next v0.0.1
git push origin next

# 작업용 브랜치 생성 (예: CI 자동 배포 세팅)
git checkout -b feature/ci-npm-setup
git push origin feature/ci-npm-setup
```

- **next 브랜치**
  - 출발점: `v0.0.1` 태그
  - semantic-release에 의해 `0.0.x-next.y` 형태의 프리릴리스 버전 자동 배포
- **작업 브랜치(feature/ci-npm-setup)**
  - CI 설정이나 기능 개발을 위한 임시 브랜치
  - 작업이 끝나면 PR을 통해 `next`로 병합 → 프리릴리스 배포
- **main 브랜치**
  - 안정화가 끝난 시점에 `next`를 병합
  - 이때 자동으로 정식(`latest`) 릴리스가 배포된다

### 의존성 설치

semantic-release는 본체만 설치해도 동작하긴 하지만, 실제로 “버전 계산 → 노트 생성 → CHANGELOG 업데이트 → GitHub Release → npm 배포”까지 풀 체인을 자동화하려면 여러 플러그인을 함께 사용해야 한다.

```bash
npm i -D semantic-release \
  @semantic-release/commit-analyzer \
  @semantic-release/release-notes-generator \
  @semantic-release/changelog \
  @semantic-release/npm \
  @semantic-release/github \
  @semantic-release/git \
  @commitlint/cli @commitlint/config-conventional \
  husky
```

- **semantic-release:** “커밋을 읽어서 어떤 버전을 올릴지 결정, 각 플러그인을 순서대로 실행”하는 오케스트레이터 역할.
- **@semantic-release/commit-analyzer:** 커밋을 읽어 **버전 증가량** 결정
- **@semantic-release/release-notes-generator:** 커밋 기반 **릴리스 노트** 생성
- **@semantic-release/changelog:** `CHANGELOG.md` 파일 생성/업데이트
- **@semantic-release/npm:** npm 배포
- **@semantic-release/github:** GitHub Release 생성
- **@semantic-release/git:** `CHANGELOG.md`/`package.json` 등을 **커밋**(선택)
- **husky:** Git 훅을 쉽게 다룰 수 있게 해준다. 보통 commit-msg 훅에서 commitlint를 실행해서, 잘못된 커밋은 아예 들어가지 못하게 막는다.

> ##### Husky가 뭐지? (왜 필요한가)
>
> **Husky**는 Git 훅(pre-commit, commit-msg, pre-push 등)을 **간단한 스크립트로 관리**하게 해주는 도구다.
> 원래 Git 훅은 `.git/hooks/` 안에 쉘 스크립트를 직접 넣어야 해서 번거롭고, 팀원마다 설정이 달라지기 쉬웠다.
> Husky를 쓰면 **레포 안에 버전 관리되는 설정**으로 훅을 공유할 수 있고, 커밋 직전에 자동으로 린트/포맷 같은 품질 체크를 실행해 **문제 있으면 커밋을 막아** 준다.
> 즉, “사람이 깜빡해도 시스템이 지켜주는 안전망”.
>
> 참고: 훅을 잠깐 건너뛰고 싶다면 `git commit --no-verify`로 우회 가능(권장 X).

### semantic-release 설정 파일

루트에 **`.releaserc.cjs`** 추가:

**.releaserc.cjs**

```ts
const isCI = !!process.env.CI; // GitHub Actions에선 기본 true

module.exports = {
  repositoryUrl: 'git@github.com:lynjs-dev/lynjs.git',
  branches: ['main', { name: 'next', prerelease: true }],
  plugins: [
    [
      '@semantic-release/commit-analyzer',
      {
        preset: 'conventionalcommits',
        releaseRules: [
          { breaking: true, release: 'major' },
          { type: 'feat', release: 'minor' },
          { type: 'fix', release: 'patch' },
          { type: 'docs', release: false },
          { type: 'docs', scope: 'release', release: 'patch' },
          { type: 'chore', release: false },
          { type: 'chore', scope: 'release', release: 'patch' },
        ],
      },
    ],
    ['@semantic-release/release-notes-generator', { preset: 'conventionalcommits' }],

    // === 아래 4개는 CI에서만 실행 ===
    isCI && ['@semantic-release/changelog', { changelogFile: 'CHANGELOG.md' }],
    isCI && ['@semantic-release/npm', { tarballDir: 'dist-tarball' }],
    isCI && ['@semantic-release/github', { assets: 'dist-tarball/*.tgz' }],
    isCI && [
      '@semantic-release/git',
      {
        assets: ['CHANGELOG.md', 'package.json'],
        message: 'chore(release): ${nextRelease.version} [skip ci]\n\n${nextRelease.notes}',
      },
    ],
  ].filter(Boolean),
};
```

- **branches**
  - `main` → 안정 채널(`latest`)
  - `next`(prerelease: true) → 프리릴리스 채널(`next`) + 버전 접미사(`-next.x`)
- **npm 플러그인**
  - `tarballDir`에 배포 아티팩트를 남겨 GitHub Release에 첨부
- **git 플러그인**
  - 릴리스마다 `CHANGELOG.md`와 `package.json`을 커밋(선택 기능, 투명성 ↑)

> 원치 않으면 `@semantic-release/git`에서 `package.json`을 빼도 된다.
> (semantic-release는 **커밋 없이도** npm에 최신 버전으로 배포 가능)

### Conventional Commits 강제(권장)

`commitlint + husky`로 커밋 규칙을 강제한다.

#### 1. **commitlint 설정:**

**`commitlint.config.cjs`**

```js
module.exports = {
  extends: ['@commitlint/config-conventional'],
};
```

#### 2. **husky 초기화 & 훅 추가**

```bash
npx husky init
# .husky/pre-commit 에 팀의 기존 린트/테스트가 있다면 유지
# 커밋 메시지 검사 훅 추가
```

**.husky/commit-msg**

```bash
# CI에서는 커밋 메시지 검사 스킵
[ -n "$CI" ] && exit 0
npx --no-install commitlint --edit "$1"
```

> 이제 **규칙에 어긋난 커밋 메시지**는 아예 들어오지 못한다.
> (예: `feat: ...`, `fix: ...`, `feat!: ...` 등)
>
> Commit 메시지 규칙은 별도로 설명 하겠다.

### 스크립트 작성

semantic-release는 CLI 형태로 실행되기 때문에 `npx semantic-release`로도 바로 돌릴 수 있다.
하지만 매번 긴 명령어를 입력하는 대신, `package.json`의 `scripts`에 짧게 등록해두면 CI나 로컬에서 실행할 때 편하다.

**package.json**

```json
{
  "scripts": {
    "release": "semantic-release"
  }
}
```

- **release:** semantic-release 실행 스크립트. CI/CD에서 릴리스를 트리거할 때 사용

> **--dry-run 옵션 활용하기**
>
> semantic-release는 자동으로 버전 증가, CHANGELOG 업데이트, GitHub Release, npm 배포까지 다 해버린다.
> 그런데 바로 CI에 붙이기 전에, “내가 작성한 커밋 메시지들이 실제로 어떤 버전 증가로 이어질지” 확인하고 싶은 경우가 많다.
> 이럴 때 쓰는 게 바로 --dry-run 옵션이다.
>
> **실행 방법**
>
> ```bash
> npm run semantic-release -- --dry-run
> ```

### GitHub Actions 워크플로우

태그 트리거가 아니라 **브랜치 푸시**를 트리거로 쓰는 게 semantic-release 정석이다.
semantic-release가 **직접 버전/태그/릴리스**를 만든다.

`.github/workflows/release.yml`

```yaml
name: Release (semantic-release)

on:
  push:
    branches: [main, next] # 브랜치 기반 트리거
  workflow_dispatch: {}

permissions:
  contents: write # 릴리스/태그 작성
  issues: write # (옵션) 릴리스 결과 코멘트 등
  pull-requests: write

jobs:
  release:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # 전체 히스토리(모든 커밋)을 가져옴. 커밋/태그 이력 필요
          fetch-tags: true # 원격 태그까지 함께 받아옴. 이전 태그 히스토리 필요

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: npm
          registry-url: 'https://registry.npmjs.org'

      - name: Install
        run: npm ci

      # (옵션) 테스트/빌드
      # - name: Test
      #   run: npm test
      # - name: Build
      #   run: npm run build

      - name: Configure npm auth
        run: echo "//registry.npmjs.org/:_authToken=${NPM_TOKEN}" > ~/.npmrc
        env:
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
          # HUSKY: 0   # CI에서 HUSKY 훅 비활성화(충돌 방지)
        run: npm run release
```

- `main`에 머지 → `latest`로 배포
- `next`에 머지 → `next`로 프리릴리스 배포
- `GITHUB_TOKEN`/`NPM_TOKEN` 환경변수로 인증 처리

### 첫 실행 체크 (Dry Run)

실제 배포 전, 로컬에서 **무엇을 할지 미리 보기**가 가능하다.

```bash
npx semantic-release --dry-run
```

- 어떤 버전으로 올릴지, 어떤 노트를 쓸지, 어떤 채널로 배포할지를 **로그로 미리 확인**할 수 있다.

## 프리릴리스 배포 흐름

자동 배포는 사람이 직접 `npm publish`를 실행하지 않는다.
대신 **커밋 → PR → next 병합 → CI** 단계를 거치면, semantic-release가 알아서 버전을 계산하고 프리릴리스(`next` 채널) 배포를 진행한다.

### 1. 작업 브랜치에서 커밋

기능 추가나 CI 설정 같은 변경사항을 작업 브랜치(`feature/...`)에 커밋한다.
커밋 메시지는 **Conventional Commits 규칙**을 따라야 버전이 올바르게 계산된다.

```bash
git add .
git commit -m "feat: add initial semantic-release setup"
git push origin feature/ci-npm-setup
```

### 2. Pull Request 생성

- `feature/ci-npm-setup` → `next`로 PR을 연다.
- 리뷰 및 테스트가 통과되면 머지한다.

### 3. next 브랜치 병합 → 자동 배포

- PR이 머지되면 GitHub Actions가 실행된다.
- semantic-release가 커밋 로그를 분석해 `0.0.x-next.y` 같은 버전을 계산한다.
- `CHANGELOG.md` 업데이트 → 태그 생성 → GitHub Release → npm `next` 채널 배포까지 자동 처리된다.

### 4. main 브랜치로 승격

- 충분히 안정화되면 `next` 브랜치를 `main`에 병합한다.
- 이때는 프리릴리스가 아닌 **정식 릴리스(`latest`)**로 배포된다.

### 운영 루틴

- **작업 브랜치 → PR → main/next 머지**
- 머지되면 CI가 자동으로:
  1. 커밋 분석 → 버전 결정
  2. CHANGELOG 갱신
  3. Git 태그 + GitHub Release
  4. npm publish (`main`→`latest`, `next`→`next`)
- 사람이 할 일: **Conventional Commits 형식으로 커밋**하고 **PR을 머지**하는 것뿐.

## 활용 방법

- **브랜치 보호 규칙:** `main`/`next`에 CI 필수 체크를 걸어 **깨진 릴리스 차단**
- **문서 연동:** 릴리스에 맞춰 문서(예: Astro) 빌드/배포 워크플로우를 **후속 잡**으로 연결
- **패치/핫픽스:** 급하면 `fix: ...`로 작은 PR 만들어 `main`에 바로 머지 → 자동 패치 릴리스
- **프리릴리스 검증:** 새로운 기능은 먼저 `next`에 누적해서 사용자 일부가 미리 쓰게 하고, 안정화되면 `main`에 합쳐 **정식 승격**
- **문제 상황 빠른 대처**
  - “버전이 안 올라간다” → 커밋 타입이 `feat/fix/BREAKING CHANGE` 계열인지 확인
  - “npm 권한 에러” → Automation Token/스코프 권한/`publishConfig.access: public` 점검
  - “CHANGELOG가 안 생긴다” → `.releaserc.json`에 `@semantic-release/changelog`/`@semantic-release/git` 포함 여부 확인

**semantic-release = 커밋 규칙만 잘 지키면 “버전·릴리스·배포”를 알아서 해주는 봇.**
지금처럼 루트 패키지 하나만 배포하는 단계에서도 **도입 가치가 충분**하고, 추후 여러 패키지로 늘어나도 철학은 그대로 가져갈 수 있다.

오케이, **잘못 배포됐을 때 되돌리는 빠른 레시피**만 깔끔하게 정리할게요.
(바로 복붙해서 쓰도록 명령어 위주)

## Git에서 잘못된 릴리스/태그 지우기

### (A) 원격 태그 하나만 삭제

```bash
# 로컬/원격 태그 동시 삭제
git tag -d v1.0.0-next.5
git push origin :refs/tags/v1.0.0-next.5
```

### (B) GitHub Release까지 같이 삭제 (있다면)

```bash
# gh CLI 설치되어 있을 때
gh release delete v1.0.0-next.5 -y --cleanup-tag
```

### (C) 태그를 여러 개 한 번에 삭제

```bash
git fetch --tags
git tag -l 'v1.0.0-next.*' | xargs -n1 -I {} git push origin :refs/tags/{}
git tag -l 'v1.0.0-next.*' | xargs -n1 git tag -d
```

> 메모
>
> - semantic-release는 **Git 태그를 기준으로 이전 릴리스**를 판단합니다.
> - 액션에서 태그를 제대로 읽게 **checkout** 스텝에 `fetch-depth: 0`, `fetch-tags: true` 유지하세요.

## npm에 잘못 올라간 **특정 버전** 삭제/차단

### 배포 **24시간 이내**면 → 삭제 가능

```bash
npm unpublish <패키지>@<버전>
# 예: npm unpublish @moe.js/test-project@1.0.0-next.5
```

### 24시간 **지났다면 삭제 불가** → deprecate로 차단

```bash
npm deprecate <패키지>@<버전> "⚠️ 잘못된 릴리스입니다. 새 버전을 사용하세요."
# 예: npm deprecate @moe.js/test-project@1.0.0-next.5 "broken: use 1.0.0-next.6+"
```

### dist-tag 정정 (latest/next 잘못 붙었을 때)

```bash
# 잘못된 태그 제거
npm dist-tag rm <패키지> latest
# 올바른 버전에 재지정
npm dist-tag add <패키지>@<버전> latest

# 예: next 채널 교체
npm dist-tag rm @moe.js/test-project next
npm dist-tag add @moe.js/test-project@1.0.0-next.6 next
```

> 중요
>
> - **이미 배포된 버전은 같은 번호로 다시 배포할 수 없습니다.**
> - 삭제 가능 시간(24h)을 넘겼다면, 보통 *deprecate + 다음 버전 재배포*로 해결합니다.

## npm에서 **프로젝트 전체 삭제** (진짜 마지막 수단)

```bash
npm unpublish <패키지> --force
# 예: npm unpublish @test.js/test-project --force
```

- 24시간 동안 동일 이름으로 패키지 배포 불가
- 완전히 되돌릴 수 없다. 모든 버전이 사라짐
- 같은 이름을 **다른 사람이 가져갈 수** 있으니, 즉시 재 배포를 진행 필요
- 공개 패키지에 의존하는 다른 프로젝트가 있으면 **절대 권장하지 않음**

## 버전 라인 재정렬(다시 0.x부터 시작하고 싶을 때)

1. **Git 기준 태그 재설정** (예: `v0.0.1`부터 시작):

```bash
git checkout next   # 또는 main
git pull --rebase
git tag -a v0.0.1 -m "baseline: start from v0.0.1"
git push origin v0.0.1
```

2. **액션에서 태그를 보도록:**

```yaml
- uses: actions/checkout@v4
  with:
    fetch-depth: 0
    fetch-tags: true
```

3. **이후 커밋 타입에 따라:**

- `fix:` → `0.0.2[-next.0]`
- `feat:` → `0.1.0[-next.0]`

> 참고: **package.json의 version은 기준이 아님.**
> semantic-release는 **Git 태그**만 보고 이전 릴리스를 계산한다.

---

## 빠른 상태 점검 커맨드

```bash
# npm 쪽
npm view <패키지> versions --json
npm view <패키지> dist-tags

# git 태그
git fetch --tags
git tag --list | sort -V
```

---

## 사고 예방 팁 (다음부터 안 꼬이게)

- 액션에서 **`fetch-depth: 0` + `fetch-tags: true`** 필수
- 릴리스 전 로컬에서 **dry-run**
  ```bash
  npx semantic-release --dry-run
  ```
- commitlint + husky로 **커밋 타입 강제**
- 실수 태그 푸시를 막으려면 **태그 트리거 배포는 쓰지 않고**, semantic-release 정석처럼 **브랜치 푸시 기반**으로 운영
