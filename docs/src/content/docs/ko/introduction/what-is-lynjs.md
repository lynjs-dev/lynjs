---
title: LynJS란 무엇인가
slug: ko/introduction/what-is-lynjs
locale: ko
---

## 개요

**LynJS**는 현대적이고 표준을 준수하는 웹 컴포넌트 및 재사용 가능한 디자인 시스템을 구축하기 위한 가볍고 세밀한 반응성
프레임워크입니다.

가상 DOM이나 무거운 추상화에 의존하는 대신, LynJS는 내부적으로 효율적인 세밀한 반응성 모델과 네이티브 커스텀 엘리먼트 및
섀도우 DOM을 결합하여 정확하고 최소한의 업데이트를 제공하며 런타임 오버헤드를 낮게 유지합니다.

클래스 기반 패턴과 `@attr`, `@watch` 같은 명확한 데코레이터를 사용하여 컴포넌트를 작성하므로 코드가 읽기 쉽고 유지보수가
용이하며 재사용 가능하여 확장 가능한 UI 라이브러리에 이상적입니다.

LynJS를 사용하면 특정 프런트엔드 스택에 종속되지 않고 다양한 환경에서 원활하게 작동하는 웹 컴포넌트를 구축할 수
있습니다.

## 철학

LynJS는 어떻게 작동하고 왜 존재하는지를 안내하는 세 가지 핵심 원칙을 중심으로 설계되었습니다.

### 표준 우선

LynJS는 커스텀 엘리먼트, 섀도우 DOM, 슬롯과 같은 네이티브 웹 컴포넌트 표준 위에 구축되었습니다. 플랫폼에 가까이
머무름으로써 브라우저 및 기타 도구와의 광범위한 호환성을 보장하며, 컴포넌트를 진정으로 프레임워크에 구애받지 않게
만듭니다. 이를 통해 단독 페이지부터 대규모 애플리케이션까지 어디서나 UI를 재사용할 수 있습니다.

이 웹 표준을 활용함으로써 LynJS는 특정 프레임워크나 생태계에 종속되는 함정을 피하고, 컴포넌트가 미래에도 호환 가능하고
상호 운용 가능하도록 보장합니다. 이 접근법은 브라우저 최적화 및 웹 컴포넌트 주위의 성장하는 생태계의 이점도 누릴 수
있습니다.

### 세밀한 효율성

가상 DOM 디핑 시스템 대신, LynJS는 내부적으로 세밀한 반응성 모델을 사용합니다. 이는 상태의 각 부분이 자신의 변화를
추적하여 해당 상태에 의존하는 컴포넌트의 정확한 부분만 업데이트된다는 뜻입니다. 결과적으로 브라우저의 작업량이 줄고
런타임 오버헤드가 최소화된 빠른 인터페이스를 제공합니다.

이 세밀한 추적 덕분에 LynJS는 정확한 업데이트를 수행하며 불필요한 재렌더링을 피하고, 특히 복잡한 UI 시나리오에서 성능을
향상시킵니다. 업데이트 중 수행되는 작업량을 최소화하여 LynJS는 메모리 및 CPU 사용량을 줄이면서 부드러운 사용자 경험을
제공합니다.

### 선언적이고 익숙한

LynJS는 ES 클래스 문법과 데코레이터를 사용하여 컴포넌트 로직을 명확하고 읽기 쉽게 만듭니다. `@attr` 같은 데코레이터로
속성을 선언하고, `@watch`로 변경에 반응하도록 하여 수동 옵저버 작성이나 보일러플레이트 연결 없이 동작을 명확히 선언할 수
있습니다. 이는 코드를 유지보수하기 쉽고 예측 가능하며 팀 간 공유 및 확장에도 용이하게 만듭니다.

선언적 스타일은 최신 자바스크립트 패턴과 일치하여 인지 부하를 줄이고 신규 개발자 온보딩을 쉽게 합니다. 일반적인 작업에
대해 명확하고 간결한 API를 제공함으로써 LynJS는 명확성과 제어를 유지하면서 견고한 컴포넌트를 더 빠르게 작성할 수 있도록
도와줍니다.

### 일관되고 품질 높은 코드 설계

LynJS는 개발자의 경험 수준에 관계없이 일관된 코드 구조를 유지하고 기본적인 코드 품질을 강제하는 데 중점을 두고
설계되었습니다. 대규모 디자인 시스템을 설계하는 시니어 개발자든 첫 컴포넌트를 만드는 주니어 개발자든, LynJS는 깨끗하고
유지보수 가능하며 예측 가능한 코드를 만드는 패턴을 장려합니다.

데코레이터 기반 API, 구조화된 믹스인 시스템, 속성, 이벤트, 접근성 속성의 자동 처리 등을 통해 LynJS는 인적 오류 가능성을
줄이고 기본적으로 모범 사례를 강제합니다. 이는 코드 리뷰를 쉽게 하고 온보딩을 빠르게 하며 장기 유지보수를 더 지속
가능하게 만듭니다.

불필요한 유연성을 제한하고 구성보다 관례를 우선시함으로써 LynJS는 프로젝트나 조직 전반에 걸쳐 컴포넌트가 일관된 모습과
동작을 유지하도록 하여 팀이 품질을 희생하지 않고 더 빠르게 움직일 수 있게 합니다.

## 주요 기능

LynJS는 웹 컴포넌트 구축을 간단하고 신뢰성 있게 만드는 도구 세트를 제공합니다.

- **LynElement:** 내장된 라이프사이클과 반응성을 가진 커스텀 엘리먼트를 정의하기 위한 기본 클래스입니다.
- **데코레이터:** `@attr` 및 `@state`로 속성에 연결된 반응성 프로퍼티를 선언하고, `@watch`로 변경에 반응하며, `@comp`로
  간단한 컴포넌트 조합을 지원합니다.
- **부수 효과 유틸리티:** `connected`, `safeInterval`, `safeTimeout` 같은 함수는 컴포넌트의 라이프사이클 내에서 부수
  효과를 안전하게 관리하기 위해 **`render` 메서드 내에서만 사용**하도록 설계되었습니다.
- **JSX 지원:** 친숙한 JSX 문법을 사용하여 선언적으로 템플릿을 작성할 수 있습니다.
- **유연하고 확장 가능:** LynJS는 기타 데코레이터와 헬퍼도 제공하며, 전체 목록은
  [Core API Reference](/docs/core-api/)에서 확인할 수 있습니다.

## 작동 방식

LynJS는 네이티브 웹 컴포넌트의 힘과 내부 세밀한 반응성 엔진을 결합하여 작동합니다.

`@attr` 또는 `@state`로 반응성 프로퍼티를 정의하면 LynJS가 자동으로 이를 반응성으로 만듭니다. 템플릿에서 이 프로퍼티를
사용하는 부분은 변경 시 자동으로 업데이트되며 전체 재렌더링이 필요 없습니다.

컴포넌트의 `render` 메서드는 JSX를 사용하여 초기 구조를 설명합니다. 엘리먼트가 DOM에 연결되면 LynJS는 어떤 DOM 부분이
어떤 반응성 프로퍼티에 의존하는지 추적합니다. 프로퍼티가 변경되면 LynJS는 영향을 받는 부분만 효율적으로 업데이트합니다.

타이머나 사용자 정의 동작 같은 부수 효과는 `render` 메서드 내에서 `connected`, `safeInterval`, `safeTimeout`을 사용해
선언할 수 있습니다. 이 유틸리티들은 컴포넌트가 연결될 때 부수 효과가 시작되고 분리될 때 자동으로 정리되도록 보장합니다.

### 기술적 흐름

LynJS가 내부적으로 작동하는 고수준 흐름은 다음과 같습니다:

1. **선언:** `LynElement`를 확장하고 `@attr`로 반응성 프로퍼티를 정의합니다.
2. **신호 설정:** 각 `@attr` 프로퍼티는 읽기 및 쓰기를 추적하는 내부 신호로 래핑됩니다.
3. **렌더링 단계:** 컴포넌트가 연결될 때 `render` 메서드가 한 번 호출되어 JSX로 초기 DOM을 생성합니다.
4. **의존성 추적:** 템플릿이 반응성 프로퍼티를 사용할 때 LynJS는 어떤 DOM 부분이 어떤 신호에 의존하는지 추적합니다.
5. **업데이트:** 프로퍼티가 변경되면 해당 프로퍼티를 사용하는 정확한 부분만 다시 실행되고 DOM에 패치됩니다.
6. **감시:** `@watch` 데코레이터가 붙은 메서드는 대상 프로퍼티가 변경될 때 자동으로 실행됩니다.
7. **부수 효과:** `render` 내에서 `connected` 등 헬퍼를 사용해 부수 효과를 안전하게 관리합니다.

이 세밀한 업데이트 모델은 불필요한 작업을 피하고 컴포넌트를 빠르고 견고하게 유지합니다.

## 왜 LynJS를 사용해야 하는가

LynJS는 최소한의 오버헤드로 빠르고 현대적인 웹 컴포넌트를 구축하려는 경우 훌륭한 선택입니다.

- **프레임워크 독립성:** LynJS로 만든 컴포넌트는 표준 커스텀 엘리먼트이므로 어디서나 실행 가능하며 특정 프런트엔드
  스택에 종속되지 않습니다.
- **높은 성능:** 세밀한 반응성은 필요한 부분만 업데이트하여 UI를 부드럽고 효율적으로 유지합니다.
- **명확하고 유지보수 용이:** 클래스 기반 문법과 데코레이터로 보일러플레이트 없이 반응 상태와 부수 효과를 선언하기
  쉽습니다.
- **안전한 부수 효과:** `connected`, `safeInterval` 같은 라이프사이클 인지 헬퍼로 부수 효과 관리를 예측 가능하고
  안정적으로 만듭니다.
- **디자인 시스템에 완벽:** 슬롯, 섀도우 DOM, 표준 속성으로 LynJS는 팀과 프로젝트 전반에 걸쳐 확장 가능한 재사용 UI
  라이브러리를 만드는 데 이상적입니다.

## 기본 예제

아래는 반응성 프로퍼티 선언, 부수 효과 처리, JSX 렌더링 방법을 보여주는 간단한 LynJS 컴포넌트 예제입니다.

```tsx
import { LynElement, attr, state, element, safeInterval } from '@lynjs/core';

@element('my-counter')
export class MyCounter extends LynElement {
  @attr count = 0;
  @state running = true;

  render() {
    // SafeInterval automatically starts and organizes intervals according to the component life cycle.
    safeInterval(() => {
      if (this.running) this.count++;
    }, 1000);

    return (
      <button onClick={this.toggle}>
        Count: {this.count} ({this.running ? 'Pause' : 'Resume'})
      </button>
    );
  }

  protected toggle() {
    this.running = !this.running;
  }
}
```

이 예제에서:

- 버튼을 클릭하면 카운터가 실행 중과 일시 중지 상태를 전환합니다.
- `pause`는 타이머를 멈추고, `resume`은 다시 시작합니다.
- `connected`는 컴포넌트가 연결될 때 타이머가 시작되고 분리될 때 멈추도록 보장합니다.
